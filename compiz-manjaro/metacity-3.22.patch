diff -Npur compiz-0.9.13.0.orig/compizconfig/gsettings/gsettings_backend_shared/ccs_gsettings_backend.c compiz-0.9.13.0/compizconfig/gsettings/gsettings_backend_shared/ccs_gsettings_backend.c
--- compiz-0.9.13.0.orig/compizconfig/gsettings/gsettings_backend_shared/ccs_gsettings_backend.c	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/compizconfig/gsettings/gsettings_backend_shared/ccs_gsettings_backend.c	2016-10-15 10:09:09.000000000 +0200
@@ -93,7 +93,8 @@ ccsGSettingsValueChanged (GSettings   *s
 
     g_value_unset (&schemaNameValue);
 
-    updateSettingWithGSettingsKeyName (backend, wrapper, keyName, backendInterface->updateSetting);
+    if (wrapper)
+	updateSettingWithGSettingsKeyName (backend, wrapper, keyName, backendInterface->updateSetting);
 }
 
 static CCSGSettingsWrapper *
diff -Npur compiz-0.9.13.0.orig/compizconfig/gsettings/gsettings_backend_shared/ccs_gsettings_interface_wrapper.c compiz-0.9.13.0/compizconfig/gsettings/gsettings_backend_shared/ccs_gsettings_interface_wrapper.c
--- compiz-0.9.13.0.orig/compizconfig/gsettings/gsettings_backend_shared/ccs_gsettings_interface_wrapper.c	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/compizconfig/gsettings/gsettings_backend_shared/ccs_gsettings_interface_wrapper.c	2016-10-15 10:09:09.000000000 +0200
@@ -15,25 +15,49 @@ struct _CCSGSettingsWrapperPrivate
 #define GSETTINGS_WRAPPER_PRIVATE(w) \
     CCSGSettingsWrapperPrivate *gswPrivate = (CCSGSettingsWrapperPrivate *) ccsObjectGetPrivate (w);
 
+static Bool keyIsValid (GSettings *settings, const char *key)
+{
+    GSettingsSchema *schema;
+    Bool valid = FALSE;
+
+    if (!settings)
+        return valid;
+
+    g_object_get (settings, "settings-schema", &schema, NULL);
+
+    if (schema)
+    {
+	valid = g_settings_schema_has_key (schema, key);
+	g_settings_schema_unref (schema);
+    }
+
+    return valid;
+}
+
 static GVariant * ccsGSettingsWrapperGetValueDefault (CCSGSettingsWrapper *wrapper, const char *key)
 {
     GSETTINGS_WRAPPER_PRIVATE (wrapper);
 
-    return g_settings_get_value (gswPrivate->settings, key);
+    if (keyIsValid (gswPrivate->settings, key))
+	return g_settings_get_value (gswPrivate->settings, key);
+    else
+	return NULL;
 }
 
 static void ccsGSettingsWrapperSetValueDefault (CCSGSettingsWrapper *wrapper, const char *key, GVariant *variant)
 {
     GSETTINGS_WRAPPER_PRIVATE (wrapper);
 
-    g_settings_set_value (gswPrivate->settings, key, variant);
+    if (keyIsValid (gswPrivate->settings, key))
+	g_settings_set_value (gswPrivate->settings, key, variant);
 }
 
 static void ccsGSettingsWrapperResetKeyDefault (CCSGSettingsWrapper *wrapper, const char *key)
 {
     GSETTINGS_WRAPPER_PRIVATE (wrapper);
 
-    g_settings_reset (gswPrivate->settings, key);
+    if (keyIsValid (gswPrivate->settings, key))
+	g_settings_reset (gswPrivate->settings, key);
 }
 
 static char ** ccsGSettingsWrapperListKeysDefault (CCSGSettingsWrapper *wrapper)
diff -Npur compiz-0.9.13.0.orig/compizconfig/gsettings/gsettings_backend_shared/gsettings_util.c compiz-0.9.13.0/compizconfig/gsettings/gsettings_backend_shared/gsettings_util.c
--- compiz-0.9.13.0.orig/compizconfig/gsettings/gsettings_backend_shared/gsettings_util.c	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/compizconfig/gsettings/gsettings_backend_shared/gsettings_util.c	2016-10-15 10:09:09.000000000 +0200
@@ -452,24 +452,24 @@ getNameForCCSSetting (CCSSetting *settin
 }
 
 Bool
-checkReadVariantIsValid (GVariant *gsettingsValue, CCSSettingType type, const gchar *pathName)
+checkReadVariantIsValid (GVariant *gsettingsValue, CCSSettingType type, const gchar *pathName, const gchar *key)
 {
     /* first check if the key is set */
     if (!gsettingsValue)
     {
-	ccsWarning ("There is no key at the path %s. "
-		"Settings from this path won't be read. Try to remove "
-		"that value so that operation can continue properly.",
-		pathName);
+	ccsWarning ("There is no key '%s' at the path %s. "
+		"Settings from this path won't be read. Default value will be used."
+		"Ensure this setting is available or the setting backend is properly configured.",
+		key, pathName);
 	return FALSE;
     }
 
     if (!variantIsValidForCCSType (gsettingsValue, type))
     {
-	ccsWarning ("There is an unsupported value at path %s. "
-		"Settings from this path won't be read. Try to remove "
-		"that value so that operation can continue properly.",
-		pathName);
+	ccsWarning ("There is an unsupported value for key '%s' at path %s. "
+		"Settings from this path won't be read. Default value will be used. "
+		"Ensure this setting is available or the setting backend is properly configured.",
+		key, pathName);
 	return FALSE;
     }
 
@@ -481,9 +481,10 @@ getVariantAtKey (CCSGSettingsWrapper *se
 {
     GVariant *gsettingsValue = ccsGSettingsWrapperGetValue (settings, key);
 
-    if (!checkReadVariantIsValid (gsettingsValue, type, pathName))
+    if (!checkReadVariantIsValid (gsettingsValue, type, pathName, key))
     {
-	g_variant_unref (gsettingsValue);
+	if (gsettingsValue)
+	    g_variant_unref (gsettingsValue);
 	return NULL;
     }
 
diff -Npur compiz-0.9.13.0.orig/compizconfig/gsettings/gsettings_backend_shared/gsettings_util.h compiz-0.9.13.0/compizconfig/gsettings/gsettings_backend_shared/gsettings_util.h
--- compiz-0.9.13.0.orig/compizconfig/gsettings/gsettings_backend_shared/gsettings_util.h	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/compizconfig/gsettings/gsettings_backend_shared/gsettings_util.h	2016-10-15 10:09:09.000000000 +0200
@@ -109,7 +109,7 @@ gchar *
 getNameForCCSSetting (CCSSetting *setting);
 
 Bool
-checkReadVariantIsValid (GVariant *gsettingsValue, CCSSettingType type, const gchar *pathName);
+checkReadVariantIsValid (GVariant *gsettingsValue, CCSSettingType type, const gchar *pathName, const gchar *key);
 
 GVariant *
 getVariantAtKey (CCSGSettingsWrapper *settings, const char *key, const char *pathName, CCSSettingType type);
diff -Npur compiz-0.9.13.0.orig/compizconfig/gsettings/tests/test_gsettings_tests.cpp compiz-0.9.13.0/compizconfig/gsettings/tests/test_gsettings_tests.cpp
--- compiz-0.9.13.0.orig/compizconfig/gsettings/tests/test_gsettings_tests.cpp	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/compizconfig/gsettings/tests/test_gsettings_tests.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -1207,14 +1207,14 @@ TEST_F(CCSGSettingsTestIndependent, Test
 
 TEST_F(CCSGSettingsTestIndependent, TestReadVariantIsValidNULL)
 {
-    EXPECT_FALSE (checkReadVariantIsValid (NULL, TypeNum, "foo/bar"));
+    EXPECT_FALSE (checkReadVariantIsValid (NULL, TypeNum, "foo/bar", "key"));
 }
 
 TEST_F(CCSGSettingsTestIndependent, TestReadVariantIsValidTypeBad)
 {
     GVariant *v = g_variant_new ("i", 1);
 
-    EXPECT_FALSE (checkReadVariantIsValid (v, TypeString, "foo/bar"));
+    EXPECT_FALSE (checkReadVariantIsValid (v, TypeString, "foo/bar", "key"));
 
     g_variant_unref (v);
 }
@@ -1223,7 +1223,7 @@ TEST_F(CCSGSettingsTestIndependent, Test
 {
     GVariant *v = g_variant_new ("i", 1);
 
-    EXPECT_TRUE (checkReadVariantIsValid (v, TypeInt, "foo/bar"));
+    EXPECT_TRUE (checkReadVariantIsValid (v, TypeInt, "foo/bar", "key"));
 
     g_variant_unref (v);
 }
diff -Npur compiz-0.9.13.0.orig/gtk/CMakeLists.txt compiz-0.9.13.0/gtk/CMakeLists.txt
--- compiz-0.9.13.0.orig/gtk/CMakeLists.txt	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/gtk/CMakeLists.txt	2016-10-15 10:09:09.000000000 +0200
@@ -25,24 +25,15 @@ if (USE_GTK)
         set (CMAKE_REQUIRED_LIBRARIES "")
 
         if (USE_METACITY)
-            pkg_check_modules (LIBMETACITY libmetacity>=3.19.1)
+            pkg_check_modules (LIBMETACITY libmetacity>=3.20.0)
 
             if (LIBMETACITY_FOUND)
-                compiz_set (HAVE_METACITY_3_20_0 1)
+                compiz_pkg_check_modules (HAVE_METACITY_3_22_0 libmetacity>=3.22.0)
 
                 set (METACITY_INCLUDE_DIRS ${LIBMETACITY_INCLUDE_DIRS})
                 set (METACITY_LIBRARIES ${LIBMETACITY_LIBRARIES})
             else (LIBMETACITY_FOUND)
-                pkg_check_modules (LIBMETACITY_PRIVATE libmetacity-private>=3.16.0)
-
-                if (LIBMETACITY_PRIVATE_FOUND)
-                    compiz_set (HAVE_METACITY_3_20_0 0)
-
-                    set (METACITY_INCLUDE_DIRS ${LIBMETACITY_PRIVATE_INCLUDE_DIRS})
-                    set (METACITY_LIBRARIES ${LIBMETACITY_PRIVATE_LIBRARIES})
-                else (LIBMETACITY_PRIVATE_FOUND)
-                    compiz_set (USE_METACITY 0)
-                endif (LIBMETACITY_PRIVATE_FOUND)
+                compiz_set (USE_METACITY 0)
             endif (LIBMETACITY_FOUND)
         endif (USE_METACITY)
 
diff -Npur compiz-0.9.13.0.orig/gtk/config.h.gtk.in compiz-0.9.13.0/gtk/config.h.gtk.in
--- compiz-0.9.13.0.orig/gtk/config.h.gtk.in	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/gtk/config.h.gtk.in	2016-10-15 10:09:09.000000000 +0200
@@ -1,7 +1,7 @@
 /* Define to 1 if Metacity support is enabled */
 #cmakedefine USE_METACITY 1
 
-/* Define to 1 if Metacity version >= 3.20.0 */
-#cmakedefine HAVE_METACITY_3_20_0 1
+/* Define to 1 if Metacity version >= 3.22.0 */
+#cmakedefine HAVE_METACITY_3_22_0 1
 
 #define GETTEXT_PACKAGE "${GETTEXT_PACKAGE}"
diff -Npur compiz-0.9.13.0.orig/gtk/window-decorator/decorator.c compiz-0.9.13.0/gtk/window-decorator/decorator.c
--- compiz-0.9.13.0.orig/gtk/window-decorator/decorator.c	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/gtk/window-decorator/decorator.c	2016-10-15 10:09:09.000000000 +0200
@@ -778,11 +778,26 @@ decor_frame_update_shadow (Display		  *x
 			   decor_shadow_options_t *opt_shadow,
 			   decor_shadow_options_t *opt_no_shadow)
 {
+    gint left, right, top, bottom;
+
     if (*shadow_normal)
     {
 	decor_shadow_destroy (xdisplay, *shadow_normal);
 	*shadow_normal = NULL;
     }
+    
+    left = frame->win_extents.left;
+    right = frame->win_extents.right;
+    top = frame->win_extents.top;
+    bottom = frame->win_extents.bottom;
+
+    if (frame->has_shadow_extents)
+    {
+	left += frame->shadow_extents.left;
+	right += frame->shadow_extents.right;
+	top += frame->shadow_extents.top;
+	bottom += frame->shadow_extents.bottom;
+    }
 
     /*
      * Warning: decor_shadow_create does more than return a decor_shadow_t*
@@ -793,19 +808,12 @@ decor_frame_update_shadow (Display		  *x
     *shadow_normal = decor_shadow_create (xdisplay,
 						 screen,
 						 1, 1,
-						 frame->win_extents.left,
-						 frame->win_extents.right,
-						 frame->win_extents.top,
-						 frame->win_extents.bottom,
-						 frame->win_extents.left -
-						 TRANSLUCENT_CORNER_SIZE,
-						 frame->win_extents.right -
-						 TRANSLUCENT_CORNER_SIZE,
-						 frame->win_extents.top -
-						 TRANSLUCENT_CORNER_SIZE,
-						 frame->win_extents.bottom -
-						 TRANSLUCENT_CORNER_SIZE,
-						 opt_shadow,
+						 left, right, top, bottom,
+						 left - TRANSLUCENT_CORNER_SIZE,
+						 right - TRANSLUCENT_CORNER_SIZE,
+						 top - TRANSLUCENT_CORNER_SIZE,
+						 bottom - TRANSLUCENT_CORNER_SIZE,
+						 frame->has_shadow_extents ? opt_no_shadow : opt_shadow,
 						 context_normal,
 						 draw_border_shape,
 						 (void *) info);
@@ -817,6 +825,19 @@ decor_frame_update_shadow (Display		  *x
 	*shadow_max = NULL;
     }
 
+    left = frame->max_win_extents.left;
+    right = frame->max_win_extents.right;
+    top = frame->max_win_extents.top;
+    bottom = frame->max_win_extents.bottom;
+
+    if (frame->has_shadow_extents)
+    {
+	left += frame->max_shadow_extents.left;
+	right += frame->max_shadow_extents.right;
+	top += frame->max_shadow_extents.top;
+	bottom += frame->max_shadow_extents.bottom;
+    }
+
     info->state = (WNCK_WINDOW_STATE_MAXIMIZED_HORIZONTALLY |
 		   WNCK_WINDOW_STATE_MAXIMIZED_VERTICALLY);
 
@@ -824,14 +845,11 @@ decor_frame_update_shadow (Display		  *x
 	decor_shadow_create (xdisplay,
 			     screen,
 			     1, 1,
-			     frame->max_win_extents.left,
-			     frame->max_win_extents.right,
-			     frame->max_win_extents.top,
-			     frame->max_win_extents.bottom,
-			     frame->max_win_extents.left - TRANSLUCENT_CORNER_SIZE,
-			     frame->max_win_extents.right - TRANSLUCENT_CORNER_SIZE,
-			     frame->max_win_extents.top - TRANSLUCENT_CORNER_SIZE,
-			     frame->max_win_extents.bottom - TRANSLUCENT_CORNER_SIZE,
+			     left, right, top, bottom,
+			     left - TRANSLUCENT_CORNER_SIZE,
+			     right - TRANSLUCENT_CORNER_SIZE,
+			     top - TRANSLUCENT_CORNER_SIZE,
+			     bottom - TRANSLUCENT_CORNER_SIZE,
 			     opt_no_shadow,  /* No shadow when maximized */
 			     context_max,
 			     draw_border_shape,
@@ -1360,13 +1378,16 @@ create_bare_frame (const gchar *type)
 
     frame->win_extents = _shadow_extents;
     frame->max_win_extents = _shadow_extents;
-    frame->win_extents = _shadow_extents;
     frame->window_context_active = _shadow_context;
     frame->window_context_inactive = _shadow_context;
     frame->max_window_context_active = _shadow_context;
     frame->max_window_context_inactive = _shadow_context;
     frame->update_shadow = bare_frame_update_shadow;
 
+    frame->has_shadow_extents = FALSE;
+    frame->shadow_extents = _shadow_extents;
+    frame->max_shadow_extents = _shadow_extents;
+
     return frame;
 }
 
@@ -1387,6 +1408,7 @@ create_normal_frame (const gchar *type)
         0, 0, 0, 0
     };
 
+    decor_extents_t _shadow_extents      = { 0, 0, 0, 0 };
     decor_extents_t _win_extents         = { 6, 6, 6, 6 };
     decor_extents_t _max_win_extents     = { 6, 6, 4, 6 };
 
@@ -1398,5 +1420,9 @@ create_normal_frame (const gchar *type)
     frame->max_window_context_active = _max_window_context;
     frame->max_window_context_inactive = _max_window_context;
 
+    frame->has_shadow_extents = FALSE;
+    frame->shadow_extents = _shadow_extents;
+    frame->max_shadow_extents = _shadow_extents;
+
     return frame;
 }
diff -Npur compiz-0.9.13.0.orig/gtk/window-decorator/gtk-window-decorator.h compiz-0.9.13.0/gtk/window-decorator/gtk-window-decorator.h
--- compiz-0.9.13.0.orig/gtk/window-decorator/gtk-window-decorator.h	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/gtk/window-decorator/gtk-window-decorator.h	2016-10-15 10:09:09.000000000 +0200
@@ -221,6 +221,10 @@ struct _decor_frame {
     gint		 text_height;
     gchar		 *type;
 
+    gboolean has_shadow_extents;
+    decor_extents_t shadow_extents;
+    decor_extents_t max_shadow_extents;
+
     frame_update_shadow_proc update_shadow;
     gint		refcount;
 };
diff -Npur compiz-0.9.13.0.orig/gtk/window-decorator/gwd-settings-storage.c compiz-0.9.13.0/gtk/window-decorator/gwd-settings-storage.c
--- compiz-0.9.13.0.orig/gtk/window-decorator/gwd-settings-storage.c	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/gtk/window-decorator/gwd-settings-storage.c	2016-10-15 10:09:09.000000000 +0200
@@ -24,7 +24,7 @@
 
 #include <gtk/gtk.h>
 
-#ifdef HAVE_METACITY_3_20_0
+#ifdef USE_METACITY
 #include <libmetacity/meta-theme.h>
 #endif
 
@@ -33,13 +33,7 @@
 
 static const gchar * ORG_COMPIZ_GWD = "org.compiz.gwd";
 static const gchar * ORG_GNOME_DESKTOP_WM_PREFERENCES = "org.gnome.desktop.wm.preferences";
-
-#ifdef HAVE_METACITY_3_20_0
 static const gchar * ORG_GNOME_METACITY_THEME = "org.gnome.metacity.theme";
-#else
-static const gchar * ORG_GNOME_METACITY = "org.gnome.metacity";
-#endif
-
 static const gchar * ORG_MATE_MARCO_GENERAL = "org.mate.Marco.general";
 
 static const gchar * ORG_COMPIZ_GWD_KEY_USE_TOOLTIPS = "use-tooltips";
@@ -51,12 +45,8 @@ static const gchar * ORG_COMPIZ_GWD_KEY_
 static const gchar * ORG_COMPIZ_GWD_KEY_USE_METACITY_THEME = "use-metacity-theme";
 static const gchar * ORG_COMPIZ_GWD_KEY_MOUSE_WHEEL_ACTION = "mouse-wheel-action";
 
-#ifdef HAVE_METACITY_3_20_0
 static const gchar * ORG_GNOME_METACITY_THEME_NAME = "name";
 static const gchar * ORG_GNOME_METACITY_THEME_TYPE = "type";
-#else
-static const gchar * ORG_GNOME_METACITY_THEME = "theme";
-#endif
 
 static const gchar * ORG_GNOME_DESKTOP_WM_PREFERENCES_ACTION_DOUBLE_CLICK_TITLEBAR = "action-double-click-titlebar";
 static const gchar * ORG_GNOME_DESKTOP_WM_PREFERENCES_ACTION_MIDDLE_CLICK_TITLEBAR = "action-middle-click-titlebar";
@@ -213,7 +203,6 @@ update_metacity_theme (GWDSettingsStorag
     if (storage->current_desktop == GWD_DESKTOP_MATE && storage->marco) {
         metacity_theme_name = g_settings_get_string (storage->marco, ORG_MATE_MARCO_GENERAL_THEME);
     } else if (storage->current_desktop == GWD_DESKTOP_GNOME_FLASHBACK && storage->metacity) {
-#ifdef HAVE_METACITY_3_20_0
         metacity_theme_type = g_settings_get_enum (storage->metacity, ORG_GNOME_METACITY_THEME_TYPE);
 
         if (metacity_theme_type == META_THEME_TYPE_GTK) {
@@ -221,9 +210,6 @@ update_metacity_theme (GWDSettingsStorag
         } else {
             metacity_theme_name = g_settings_get_string (storage->metacity, ORG_GNOME_METACITY_THEME_NAME);
         }
-#else
-        metacity_theme_name = g_settings_get_string (storage->metacity, ORG_GNOME_METACITY_THEME);
-#endif
     } else if (storage->desktop) {
         metacity_theme_name = g_settings_get_string (storage->desktop, ORG_GNOME_DESKTOP_WM_PREFERENCES_THEME);
     } else {
@@ -385,14 +371,9 @@ org_gnome_metacity_settings_changed (GSe
                                      const gchar        *key,
                                      GWDSettingsStorage *storage)
 {
-#ifdef HAVE_METACITY_3_20_0
     if (strcmp (key, ORG_GNOME_METACITY_THEME_NAME) == 0 ||
         strcmp (key, ORG_GNOME_METACITY_THEME_TYPE) == 0)
         update_metacity_theme (storage);
-#else
-    if (strcmp (key, ORG_GNOME_METACITY_THEME) == 0)
-        update_metacity_theme (storage);
-#endif
 }
 
 static void
@@ -423,12 +404,12 @@ gtk_decoration_layout_changed (GtkSettin
     update_button_layout (storage);
 }
 
-#ifdef HAVE_METACITY_3_20_0
 static void
 gtk_theme_name_changed (GtkSettings        *settings,
                         GParamSpec         *pspec,
                         GWDSettingsStorage *storage)
 {
+#ifdef USE_METACITY
     MetaThemeType type;
 
     if (!storage->metacity)
@@ -438,8 +419,8 @@ gtk_theme_name_changed (GtkSettings
 
     if (type == META_THEME_TYPE_GTK)
         update_metacity_theme (storage);
-}
 #endif
+}
 
 static void
 gwd_settings_storage_constructed (GObject *object)
@@ -573,22 +554,15 @@ gwd_settings_storage_init (GWDSettingsSt
         case GWD_DESKTOP_GNOME_FLASHBACK:
             storage->gwd = get_settings_no_abort (ORG_COMPIZ_GWD);
             storage->desktop = get_settings_no_abort (ORG_GNOME_DESKTOP_WM_PREFERENCES);
-
-#ifdef HAVE_METACITY_3_20_0
             storage->metacity = get_settings_no_abort (ORG_GNOME_METACITY_THEME);
-#else
-            storage->metacity = get_settings_no_abort (ORG_GNOME_METACITY);
-#endif
 
             storage->gtk_decoration_layout_id =
                 g_signal_connect (gtk_settings_get_default (), "notify::gtk-decoration-layout",
                                   G_CALLBACK (gtk_decoration_layout_changed), storage);
 
-#ifdef HAVE_METACITY_3_20_0
             storage->gtk_theme_name_id =
                 g_signal_connect (gtk_settings_get_default (), "notify::gtk-theme-name",
                                   G_CALLBACK (gtk_theme_name_changed), storage);
-#endif
             break;
 
         case GWD_DESKTOP_MATE:
diff -Npur compiz-0.9.13.0.orig/gtk/window-decorator/gwd-theme.c compiz-0.9.13.0/gtk/window-decorator/gwd-theme.c
--- compiz-0.9.13.0.orig/gtk/window-decorator/gwd-theme.c	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/gtk/window-decorator/gwd-theme.c	2016-10-15 10:09:09.000000000 +0200
@@ -248,13 +248,6 @@ gwd_theme_real_update_titlebar_font (GWD
 {
 }
 
-static PangoFontDescription *
-gwd_theme_real_get_titlebar_font (GWDTheme      *theme,
-                                  decor_frame_t *frame)
-{
-    return NULL;
-}
-
 static void
 gwd_theme_class_init (GWDThemeClass *theme_class)
 {
@@ -275,7 +268,6 @@ gwd_theme_class_init (GWDThemeClass *the
     theme_class->get_event_window_position = gwd_theme_real_get_event_window_position;
     theme_class->get_button_position = gwd_theme_real_get_button_position;
     theme_class->update_titlebar_font = gwd_theme_real_update_titlebar_font;
-    theme_class->get_titlebar_font = gwd_theme_real_get_titlebar_font;
 
     properties[PROP_SETTINGS] =
         g_param_spec_object ("settings", "GWDSettings", "GWDSettings",
@@ -433,11 +425,6 @@ gwd_theme_get_titlebar_font (GWDTheme
     GWDThemePrivate *priv = gwd_theme_get_instance_private (theme);
     GtkStyleContext *context = gtk_widget_get_style_context (priv->style_window);
 
-    /* Check if Metacity or Cairo will create titlebar font */
-    font_desc = GWD_THEME_GET_CLASS (theme)->get_titlebar_font (theme, frame);
-    if (font_desc)
-        return font_desc;
-
     /* Check if non-system font is in use */
     if (priv->titlebar_font)
         return pango_font_description_copy (priv->titlebar_font);
diff -Npur compiz-0.9.13.0.orig/gtk/window-decorator/gwd-theme.h compiz-0.9.13.0/gtk/window-decorator/gwd-theme.h
--- compiz-0.9.13.0.orig/gtk/window-decorator/gwd-theme.h	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/gtk/window-decorator/gwd-theme.h	2016-10-15 10:09:09.000000000 +0200
@@ -37,53 +37,50 @@ struct _GWDThemeClass
 {
     GObjectClass parent_class;
 
-    void     (* style_updated)                      (GWDTheme                   *theme);
+    void     (* style_updated)             (GWDTheme                   *theme);
 
-    void     (* get_shadow)                         (GWDTheme                   *theme,
-                                                     decor_frame_t              *frame,
-                                                     decor_shadow_options_t     *options,
-                                                     gboolean                    active);
-
-    void     (* draw_window_decoration)             (GWDTheme                   *theme,
-                                                     decor_t                    *decor);
-
-    gboolean (* calc_decoration_size)               (GWDTheme                   *theme,
-                                                     decor_t                    *decor,
-                                                     gint                        w,
-                                                     gint                        h,
-                                                     gint                        name_width,
-                                                     gint                       *width,
-                                                     gint                       *height);
-
-    void     (* update_border_extents)              (GWDTheme                   *theme,
-                                                     decor_frame_t              *frame);
-
-    void     (* get_event_window_position)          (GWDTheme                   *theme,
-                                                     decor_t                    *decor,
-                                                     gint                        i,
-                                                     gint                        j,
-                                                     gint                        width,
-                                                     gint                        height,
-                                                     gint                       *x,
-                                                     gint                       *y,
-                                                     gint                       *w,
-                                                     gint                       *h);
-
-    gboolean (* get_button_position)                (GWDTheme                   *theme,
-                                                     decor_t                    *decor,
-                                                     gint                        i,
-                                                     gint                        width,
-                                                     gint                        height,
-                                                     gint                       *x,
-                                                     gint                       *y,
-                                                     gint                       *w,
-                                                     gint                       *h);
+    void     (* get_shadow)                (GWDTheme                   *theme,
+                                            decor_frame_t              *frame,
+                                            decor_shadow_options_t     *options,
+                                            gboolean                    active);
+
+    void     (* draw_window_decoration)    (GWDTheme                   *theme,
+                                            decor_t                    *decor);
+
+    gboolean (* calc_decoration_size)      (GWDTheme                   *theme,
+                                            decor_t                    *decor,
+                                            gint                        w,
+                                            gint                        h,
+                                            gint                        name_width,
+                                            gint                       *width,
+                                            gint                       *height);
+
+    void     (* update_border_extents)     (GWDTheme                   *theme,
+                                            decor_frame_t              *frame);
+
+    void     (* get_event_window_position) (GWDTheme                   *theme,
+                                            decor_t                    *decor,
+                                            gint                        i,
+                                            gint                        j,
+                                            gint                        width,
+                                            gint                        height,
+                                            gint                       *x,
+                                            gint                       *y,
+                                            gint                       *w,
+                                            gint                       *h);
+
+    gboolean (* get_button_position)       (GWDTheme                   *theme,
+                                            decor_t                    *decor,
+                                            gint                        i,
+                                            gint                        width,
+                                            gint                        height,
+                                            gint                       *x,
+                                            gint                       *y,
+                                            gint                       *w,
+                                            gint                       *h);
 
-    void                   (* update_titlebar_font) (GWDTheme                   *theme,
-                                                     const PangoFontDescription *titlebar_font);
-
-    PangoFontDescription * (* get_titlebar_font)    (GWDTheme                   *theme,
-                                                     decor_frame_t              *frame);
+    void     (* update_titlebar_font)      (GWDTheme                   *theme,
+                                            const PangoFontDescription *titlebar_font);
 };
 
 typedef enum
diff -Npur compiz-0.9.13.0.orig/gtk/window-decorator/gwd-theme-metacity.c compiz-0.9.13.0/gtk/window-decorator/gwd-theme-metacity.c
--- compiz-0.9.13.0.orig/gtk/window-decorator/gwd-theme-metacity.c	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/gtk/window-decorator/gwd-theme-metacity.c	2016-10-15 10:09:09.000000000 +0200
@@ -27,12 +27,7 @@
 
 #include "config.h"
 
-#ifdef HAVE_METACITY_3_20_0
 #include <libmetacity/meta-theme.h>
-#else
-#include <metacity-private/theme.h>
-#include <metacity-private/theme-parser.h>
-#endif
 
 #include "gtk-window-decorator.h"
 #include "gwd-settings.h"
@@ -40,47 +35,19 @@
 
 struct _GWDThemeMetacity
 {
-    GObject                     parent;
+    GObject           parent;
 
-    MetaTheme                  *theme;
-
-#ifndef HAVE_METACITY_3_20_0
-    GHashTable                 *style_variants;
-#endif
+    MetaTheme        *theme;
 
-    gulong                      button_layout_id;
-    MetaButtonLayout            button_layout;
+    gulong            button_layout_id;
 
-#ifndef HAVE_METACITY_3_20_0
-    const PangoFontDescription *titlebar_font;
+#ifndef HAVE_METACITY_3_22_0
+    MetaButtonLayout  button_layout;
 #endif
 };
 
 G_DEFINE_TYPE (GWDThemeMetacity, gwd_theme_metacity, GWD_TYPE_THEME)
 
-#ifndef HAVE_METACITY_3_20_0
-static MetaStyleInfo *
-get_style_info (GWDThemeMetacity *metacity,
-                decor_t          *decor)
-{
-    const gchar *variant = decor != NULL ? decor->gtk_theme_variant : NULL;
-    const gchar *key = variant != NULL ? variant : "default";
-    MetaStyleInfo *style = g_hash_table_lookup (metacity->style_variants, key);
-
-    if (style == NULL) {
-        GWDTheme *theme = GWD_THEME (metacity);
-        GtkWidget *style_window = gwd_theme_get_style_window (theme);
-        GdkScreen *screen = gtk_widget_get_screen (style_window);
-
-        style = meta_theme_create_style_info (screen, variant);
-
-        g_hash_table_insert (metacity->style_variants, g_strdup (key), style);
-    }
-
-    return style;
-}
-#endif
-
 static MetaFrameType
 frame_type_from_string (const gchar *str)
 {
@@ -96,234 +63,77 @@ frame_type_from_string (const gchar *str
     return META_FRAME_TYPE_NORMAL;
 }
 
-#ifndef HAVE_METACITY_3_20_0
-static void
-initialize_button_layout (MetaButtonLayout *layout)
-{
-    gint i;
-
-    for (i = 0; i < MAX_BUTTONS_PER_CORNER; ++i) {
-        layout->left_buttons[i] = META_BUTTON_FUNCTION_LAST;
-        layout->right_buttons[i] = META_BUTTON_FUNCTION_LAST;
-        layout->left_buttons_has_spacer[i] = FALSE;
-        layout->right_buttons_has_spacer[i] = FALSE;
-    }
-}
-
-static MetaButtonFunction
-meta_button_function_from_string (const char *str)
-{
-    if (strcmp (str, "menu") == 0)
-        return META_BUTTON_FUNCTION_MENU;
-    else if (strcmp (str, "appmenu") == 0)
-        return META_BUTTON_FUNCTION_APPMENU;
-    else if (strcmp (str, "minimize") == 0)
-        return META_BUTTON_FUNCTION_MINIMIZE;
-    else if (strcmp (str, "maximize") == 0)
-        return META_BUTTON_FUNCTION_MAXIMIZE;
-    else if (strcmp (str, "close") == 0)
-        return META_BUTTON_FUNCTION_CLOSE;
-    else if (strcmp (str, "shade") == 0)
-        return META_BUTTON_FUNCTION_SHADE;
-    else if (strcmp (str, "above") == 0)
-        return META_BUTTON_FUNCTION_ABOVE;
-    else if (strcmp (str, "stick") == 0)
-        return META_BUTTON_FUNCTION_STICK;
-    else if (strcmp (str, "unshade") == 0)
-        return META_BUTTON_FUNCTION_UNSHADE;
-    else if (strcmp (str, "unabove") == 0)
-        return META_BUTTON_FUNCTION_UNABOVE;
-    else if (strcmp (str, "unstick") == 0)
-        return META_BUTTON_FUNCTION_UNSTICK;
-    else
-        return META_BUTTON_FUNCTION_LAST;
-}
-
-static MetaButtonFunction
-meta_button_opposite_function (MetaButtonFunction ofwhat)
-{
-    switch (ofwhat) {
-        case META_BUTTON_FUNCTION_SHADE:
-            return META_BUTTON_FUNCTION_UNSHADE;
-        case META_BUTTON_FUNCTION_UNSHADE:
-            return META_BUTTON_FUNCTION_SHADE;
-
-        case META_BUTTON_FUNCTION_ABOVE:
-            return META_BUTTON_FUNCTION_UNABOVE;
-        case META_BUTTON_FUNCTION_UNABOVE:
-            return META_BUTTON_FUNCTION_ABOVE;
-
-        case META_BUTTON_FUNCTION_STICK:
-            return META_BUTTON_FUNCTION_UNSTICK;
-        case META_BUTTON_FUNCTION_UNSTICK:
-            return META_BUTTON_FUNCTION_STICK;
-
-        default:
-            return META_BUTTON_FUNCTION_LAST;
-    }
-}
-#endif
-
 static void
 update_metacity_button_layout_cb (GWDSettings      *settings,
                                   const gchar      *button_layout,
                                   GWDThemeMetacity *metacity)
 {
-#ifdef HAVE_METACITY_3_20_0
     gboolean invert = gtk_widget_get_default_direction () == GTK_TEXT_DIR_RTL;
 
-    metacity->button_layout = meta_button_layout_new (button_layout, invert);
+#ifdef HAVE_METACITY_3_22_0
+    meta_theme_set_button_layout (metacity->theme, button_layout, invert);
 #else
-    MetaButtonLayout new_layout;
-
-    initialize_button_layout (&new_layout);
-
-    if (button_layout != NULL) {
-        gint i;
-        gchar **sides;
-        MetaButtonFunction f;
-
-        sides = g_strsplit (button_layout, ":", 2);
-
-        if (sides[0] != NULL) {
-            gchar **buttons;
-            gint b;
-            gboolean used[META_BUTTON_FUNCTION_LAST];
-
-            for (i = 0; i < META_BUTTON_FUNCTION_LAST; ++i)
-                used[i] = FALSE;
-
-            buttons = g_strsplit (sides[0], ",", -1);
-
-            i = b = 0;
-            while (buttons[b] != NULL) {
-                f = meta_button_function_from_string (buttons[b]);
-
-                if (i > 0 && strcmp ("spacer", buttons[b]) == 0) {
-                    new_layout.left_buttons_has_spacer[i - 1] = TRUE;
-                    f = meta_button_opposite_function (f);
-
-                    if (f != META_BUTTON_FUNCTION_LAST)
-                        new_layout.left_buttons_has_spacer[i - 2] = TRUE;
-                } else {
-                    if (f != META_BUTTON_FUNCTION_LAST && !used[f]) {
-                        used[f] = TRUE;
-                        new_layout.left_buttons[i++] = f;
-
-                        f = meta_button_opposite_function (f);
-
-                        if (f != META_BUTTON_FUNCTION_LAST)
-                            new_layout.left_buttons[i++] = f;
-                    } else {
-                        g_warning ("Ignoring unknown or already-used "
-                                   "button name \"%s\"", buttons[b]);
-                    }
-                }
-
-                ++b;
-            }
-
-            new_layout.left_buttons[i] = META_BUTTON_FUNCTION_LAST;
-
-            g_strfreev (buttons);
-
-            if (sides[1] != NULL) {
-                for (i = 0; i < META_BUTTON_FUNCTION_LAST; ++i)
-                    used[i] = FALSE;
-
-                buttons = g_strsplit (sides[1], ",", -1);
-
-                i = b = 0;
-                while (buttons[b] != NULL) {
-                    f = meta_button_function_from_string (buttons[b]);
-
-                    if (i > 0 && strcmp ("spacer", buttons[b]) == 0) {
-                        new_layout.right_buttons_has_spacer[i - 1] = TRUE;
-                        f = meta_button_opposite_function (f);
-
-                        if (f != META_BUTTON_FUNCTION_LAST)
-                            new_layout.right_buttons_has_spacer[i - 2] = TRUE;
-                    } else {
-                        if (f != META_BUTTON_FUNCTION_LAST && !used[f]) {
-                            used[f] = TRUE;
-                            new_layout.right_buttons[i++] = f;
-
-                            f = meta_button_opposite_function (f);
-
-                            if (f != META_BUTTON_FUNCTION_LAST)
-                                new_layout.right_buttons[i++] = f;
-                        } else {
-                            g_warning ("Ignoring unknown or already-used "
-                                       "button name \"%s\"", buttons[b]);
-                        }
-                    }
-
-                    ++b;
-                }
-
-                new_layout.right_buttons[i] = META_BUTTON_FUNCTION_LAST;
-
-                g_strfreev (buttons);
-            }
-        }
-
-        g_strfreev (sides);
-
-        /* Invert the button layout for RTL languages */
-        if (gtk_widget_get_default_direction () == GTK_TEXT_DIR_RTL) {
-            MetaButtonLayout rtl_layout;
-            gint j;
-
-            initialize_button_layout (&rtl_layout);
-
-            i = 0;
-            while (new_layout.left_buttons[i] != META_BUTTON_FUNCTION_LAST)
-                ++i;
-
-            for (j = 0; j < i; ++j) {
-                rtl_layout.right_buttons[j] = new_layout.left_buttons[i - j - 1];
-
-                if (j == 0)
-                    rtl_layout.right_buttons_has_spacer[i - 1] = new_layout.left_buttons_has_spacer[i - j - 1];
-                else
-                    rtl_layout.right_buttons_has_spacer[j - 1] = new_layout.left_buttons_has_spacer[i - j - 1];
-            }
+    metacity->button_layout = meta_button_layout_new (button_layout, invert);
+#endif
+}
 
-            i = 0;
-            while (new_layout.right_buttons[i] != META_BUTTON_FUNCTION_LAST)
-                ++i;
-
-            for (j = 0; j < i; ++j) {
-                rtl_layout.left_buttons[j] = new_layout.right_buttons[i - j - 1];
-
-                if (j == 0)
-                    rtl_layout.left_buttons_has_spacer[i - 1] = new_layout.right_buttons_has_spacer[i - j - 1];
-                else
-                    rtl_layout.left_buttons_has_spacer[j - 1] = new_layout.right_buttons_has_spacer[i - j - 1];
-            }
+static MetaButtonState
+meta_button_state (gint state)
+{
+    if (state & IN_EVENT_WINDOW) {
+        if (state & PRESSED_EVENT_WINDOW)
+            return META_BUTTON_STATE_PRESSED;
 
-            new_layout = rtl_layout;
-        }
-    } else {
-        gint i;
+        return META_BUTTON_STATE_PRELIGHT;
+    }
 
-        new_layout.left_buttons[0] = META_BUTTON_FUNCTION_MENU;
+    return META_BUTTON_STATE_NORMAL;
+}
 
-        for (i = 1; i < MAX_BUTTONS_PER_CORNER; ++i)
-            new_layout.left_buttons[i] = META_BUTTON_FUNCTION_LAST;
+#ifdef HAVE_METACITY_3_22_0
+static MetaButtonState
+meta_button_state_for_button_type (decor_t        *decor,
+                                   MetaButtonType  type)
+{
+    switch (type) {
+        case META_BUTTON_TYPE_CLOSE:
+            return meta_button_state (decor->button_states[BUTTON_CLOSE]);
+        case META_BUTTON_TYPE_MAXIMIZE:
+            return meta_button_state (decor->button_states[BUTTON_MAX]);
+        case META_BUTTON_TYPE_MINIMIZE:
+            return meta_button_state (decor->button_states[BUTTON_MIN]);
+        case META_BUTTON_TYPE_MENU:
+            return meta_button_state (decor->button_states[BUTTON_MENU]);
+        case META_BUTTON_TYPE_SHADE:
+            return meta_button_state (decor->button_states[BUTTON_SHADE]);
+        case META_BUTTON_TYPE_ABOVE:
+            return meta_button_state (decor->button_states[BUTTON_ABOVE]);
+        case META_BUTTON_TYPE_STICK:
+            return meta_button_state (decor->button_states[BUTTON_STICK]);
+        case META_BUTTON_TYPE_UNSHADE:
+            return meta_button_state (decor->button_states[BUTTON_UNSHADE]);
+        case META_BUTTON_TYPE_UNABOVE:
+            return meta_button_state (decor->button_states[BUTTON_UNABOVE]);
+        case META_BUTTON_TYPE_UNSTICK:
+            return meta_button_state (decor->button_states[BUTTON_UNSTICK]);
+        default:
+            break;
+    }
 
-        new_layout.right_buttons[0] = META_BUTTON_FUNCTION_MINIMIZE;
-        new_layout.right_buttons[1] = META_BUTTON_FUNCTION_MAXIMIZE;
-        new_layout.right_buttons[2] = META_BUTTON_FUNCTION_CLOSE;
+    return META_BUTTON_STATE_NORMAL;
+}
 
-        for (i = 3; i < MAX_BUTTONS_PER_CORNER; ++i)
-            new_layout.right_buttons[i] = META_BUTTON_FUNCTION_LAST;
-    }
+static MetaButtonState
+update_button_state (MetaButtonType type,
+                     GdkRectangle   rect,
+                     gpointer       user_data)
+{
+    decor_t *decor = (decor_t *) user_data;
 
-    metacity->button_layout = new_layout;
-#endif
+    return meta_button_state_for_button_type (decor, type);
 }
 
+#else
 static MetaButtonType
 meta_function_to_type (MetaButtonFunction function)
 {
@@ -356,19 +166,6 @@ meta_function_to_type (MetaButtonFunctio
 }
 
 static MetaButtonState
-meta_button_state (gint state)
-{
-    if (state & IN_EVENT_WINDOW) {
-        if (state & PRESSED_EVENT_WINDOW)
-            return META_BUTTON_STATE_PRESSED;
-
-        return META_BUTTON_STATE_PRELIGHT;
-    }
-
-    return META_BUTTON_STATE_NORMAL;
-}
-
-static MetaButtonState
 meta_button_state_for_button_type (GWDThemeMetacity *metacity,
                                    decor_t          *decor,
                                    MetaButtonType    type)
@@ -422,6 +219,7 @@ meta_button_state_for_button_type (GWDTh
 
     return META_BUTTON_STATE_NORMAL;
 }
+#endif
 
 static gint
 radius_to_width (gint radius,
@@ -448,8 +246,10 @@ get_corner_radius (const MetaFrameGeomet
 
 static Region
 get_top_border_region (const MetaFrameGeometry *fgeom,
-                       gint                     width)
+                       gboolean                 subtract_borders)
 {
+    GtkBorder invisible = fgeom->borders.invisible;
+    GtkBorder shadow = fgeom->borders.shadow;
     Region corners_xregion;
     Region border_xregion;
     XRectangle xrect;
@@ -459,6 +259,7 @@ get_top_border_region (const MetaFrameGe
     gint bottom_right_radius;
     gint w;
     gint i;
+    gint width;
     gint height;
 
     corners_xregion = XCreateRegion ();
@@ -466,10 +267,10 @@ get_top_border_region (const MetaFrameGe
     get_corner_radius (fgeom, &top_left_radius, &top_right_radius,
                        &bottom_left_radius, &bottom_right_radius);
 
-    width = width - fgeom->borders.invisible.left - fgeom->borders.invisible.right;
-    height = fgeom->borders.visible.top;
+    width = fgeom->width - invisible.left - invisible.right + shadow.left + shadow.right;
+    height = fgeom->borders.visible.top + shadow.top;
 
-    if (top_left_radius) {
+    if (top_left_radius && subtract_borders) {
         for (i = 0; i < top_left_radius; ++i) {
             w = radius_to_width (top_left_radius, i);
 
@@ -482,7 +283,7 @@ get_top_border_region (const MetaFrameGe
         }
     }
 
-    if (top_right_radius) {
+    if (top_right_radius && subtract_borders) {
         for (i = 0; i < top_right_radius; ++i) {
             w = radius_to_width (top_right_radius, i);
 
@@ -512,8 +313,10 @@ get_top_border_region (const MetaFrameGe
 
 static Region
 get_bottom_border_region (const MetaFrameGeometry *fgeom,
-                          gint                     width)
+                          gboolean                 subtract_borders)
 {
+    GtkBorder invisible = fgeom->borders.invisible;
+    GtkBorder shadow = fgeom->borders.shadow;
     Region corners_xregion;
     Region border_xregion;
     XRectangle xrect;
@@ -523,6 +326,7 @@ get_bottom_border_region (const MetaFram
     gint bottom_right_radius;
     gint w;
     gint i;
+    gint width;
     gint height;
 
     corners_xregion = XCreateRegion ();
@@ -530,10 +334,10 @@ get_bottom_border_region (const MetaFram
     get_corner_radius (fgeom, &top_left_radius, &top_right_radius,
                        &bottom_left_radius, &bottom_right_radius);
 
-    width = width - fgeom->borders.invisible.left - fgeom->borders.invisible.right;
-    height = fgeom->borders.visible.bottom;
+    width = fgeom->width - invisible.left - invisible.right + shadow.left + shadow.right;
+    height = fgeom->borders.visible.bottom + shadow.bottom;
 
-    if (bottom_left_radius) {
+    if (bottom_left_radius && subtract_borders) {
         for (i = 0; i < bottom_left_radius; ++i) {
             w = radius_to_width (bottom_left_radius, i);
 
@@ -546,7 +350,7 @@ get_bottom_border_region (const MetaFram
         }
     }
 
-    if (bottom_right_radius) {
+    if (bottom_right_radius && subtract_borders) {
         for (i = 0; i < bottom_right_radius; ++i) {
             w = radius_to_width (bottom_right_radius, i);
 
@@ -575,8 +379,7 @@ get_bottom_border_region (const MetaFram
 }
 
 static Region
-get_left_border_region (const MetaFrameGeometry *fgeom,
-                        gint                     height)
+get_left_border_region (const MetaFrameGeometry *fgeom)
 {
     Region border_xregion;
     XRectangle xrect;
@@ -585,8 +388,8 @@ get_left_border_region (const MetaFrameG
 
     xrect.x = 0;
     xrect.y = 0;
-    xrect.width = fgeom->borders.visible.left;
-    xrect.height = height - fgeom->borders.total.top - fgeom->borders.total.bottom;
+    xrect.width = fgeom->borders.visible.left + fgeom->borders.shadow.left;
+    xrect.height = fgeom->height - fgeom->borders.total.top - fgeom->borders.total.bottom;
 
     XUnionRectWithRegion (&xrect, border_xregion, border_xregion);
 
@@ -594,8 +397,7 @@ get_left_border_region (const MetaFrameG
 }
 
 static Region
-get_right_border_region (const MetaFrameGeometry *fgeom,
-                         gint                     height)
+get_right_border_region (const MetaFrameGeometry *fgeom)
 {
     Region border_xregion;
     XRectangle xrect;
@@ -604,8 +406,8 @@ get_right_border_region (const MetaFrame
 
     xrect.x = 0;
     xrect.y = 0;
-    xrect.width = fgeom->borders.visible.right;
-    xrect.height = height - fgeom->borders.total.top - fgeom->borders.total.bottom;
+    xrect.width = fgeom->borders.visible.right + fgeom->borders.shadow.right;
+    xrect.height = fgeom->height - fgeom->borders.total.top - fgeom->borders.total.bottom;
 
     XUnionRectWithRegion (&xrect, border_xregion, border_xregion);
 
@@ -652,42 +454,22 @@ decor_update_meta_window_property (GWDTh
         MetaFrameBorders borders;
 
         tmp_flags = flags & ~META_FRAME_MAXIMIZED;
-#ifdef HAVE_METACITY_3_20_0
         meta_theme_get_frame_borders (metacity->theme, d->gtk_theme_variant,
                                       type, tmp_flags, &borders);
-#else
-        meta_theme_get_frame_borders (metacity->theme, get_style_info (metacity, d),
-                                      type, d->frame->text_height, tmp_flags, &borders);
-#endif
-
-        if (flags & META_FRAME_ALLOWS_HORIZONTAL_RESIZE) {
-            frame_win_extents.left += borders.invisible.left;
-            frame_win_extents.right += borders.invisible.right;
-        }
 
-        if (flags & META_FRAME_ALLOWS_VERTICAL_RESIZE) {
-            frame_win_extents.bottom += borders.invisible.bottom;
-            frame_win_extents.top += borders.invisible.top;
-        }
+        frame_win_extents.left += borders.resize.left;
+        frame_win_extents.right += borders.resize.right;
+        frame_win_extents.bottom += borders.resize.bottom;
+        frame_win_extents.top += borders.resize.top;
 
         tmp_flags = flags | META_FRAME_MAXIMIZED;
-#ifdef HAVE_METACITY_3_20_0
         meta_theme_get_frame_borders (metacity->theme, d->gtk_theme_variant,
                                       type, tmp_flags, &borders);
-#else
-        meta_theme_get_frame_borders (metacity->theme, get_style_info (metacity, d),
-                                      type, d->frame->text_height, tmp_flags, &borders);
-#endif
-
-        if (flags & META_FRAME_ALLOWS_HORIZONTAL_RESIZE) {
-            frame_max_win_extents.left += borders.invisible.left;
-            frame_max_win_extents.right += borders.invisible.right;
-        }
 
-        if (flags & META_FRAME_ALLOWS_VERTICAL_RESIZE) {
-            frame_max_win_extents.bottom += borders.invisible.bottom;
-            frame_max_win_extents.top += borders.invisible.top;
-        }
+        frame_max_win_extents.left += borders.resize.left;
+        frame_max_win_extents.right += borders.resize.right;
+        frame_max_win_extents.bottom += borders.resize.bottom;
+        frame_max_win_extents.top += borders.resize.top;
     }
 
     w = d->border_layout.top.x2 - d->border_layout.top.x1 -
@@ -807,14 +589,14 @@ get_decoration_geometry (GWDThemeMetacit
     else
         client_height = decor->border_layout.left.y2 - decor->border_layout.left.y1;
 
-#ifdef HAVE_METACITY_3_20_0
+#ifdef HAVE_METACITY_3_22_0
     meta_theme_calc_geometry (metacity->theme, decor->gtk_theme_variant,
                               frame_type, *flags, client_width, client_height,
-                              &metacity->button_layout, fgeom);
+                              fgeom);
 #else
-    meta_theme_calc_geometry (metacity->theme, get_style_info (metacity, decor),
-                              frame_type, decor->frame->text_height, *flags, client_width,
-                              client_height, &metacity->button_layout, fgeom);
+    meta_theme_calc_geometry (metacity->theme, decor->gtk_theme_variant,
+                              frame_type, *flags, client_width, client_height,
+                              &metacity->button_layout, fgeom);
 #endif
 }
 
@@ -862,6 +644,38 @@ calc_button_size (GWDTheme *theme,
     decor->button_width = width - min_x;
 }
 
+#ifdef HAVE_METACITY_3_22_0
+static MetaButtonType
+button_to_meta_button_type (gint i)
+{
+    switch (i) {
+        case BUTTON_MENU:
+            return META_BUTTON_TYPE_MENU;
+        case BUTTON_MIN:
+            return META_BUTTON_TYPE_MINIMIZE;
+        case BUTTON_MAX:
+            return META_BUTTON_TYPE_MAXIMIZE;
+        case BUTTON_CLOSE:
+            return META_BUTTON_TYPE_CLOSE;
+        case BUTTON_SHADE:
+            return META_BUTTON_TYPE_SHADE;
+        case BUTTON_ABOVE:
+            return META_BUTTON_TYPE_ABOVE;
+        case BUTTON_STICK:
+            return META_BUTTON_TYPE_STICK;
+        case BUTTON_UNSHADE:
+            return META_BUTTON_TYPE_UNSHADE;
+        case BUTTON_UNABOVE:
+            return META_BUTTON_TYPE_UNABOVE;
+        case BUTTON_UNSTICK:
+            return META_BUTTON_TYPE_UNSTICK;
+        default:
+            break;
+    }
+
+    return META_BUTTON_TYPE_LAST;
+}
+#else
 static gboolean
 button_present (GWDThemeMetacity   *metacity,
                 MetaButtonFunction  function)
@@ -909,18 +723,15 @@ button_to_meta_button_function (gint i)
 
     return META_BUTTON_FUNCTION_LAST;
 }
+#endif
 
 static gboolean
 setup_theme (GWDThemeMetacity *metacity)
 {
     GWDSettings *settings = gwd_theme_get_settings (GWD_THEME (metacity));
     const gchar *metacity_theme_name = gwd_settings_get_metacity_theme_name (settings);
-#ifdef HAVE_METACITY_3_20_0
     gint metacity_theme_type = gwd_settings_get_metacity_theme_type (settings);
     GError *error = NULL;
-#else
-    MetaTheme *theme;
-#endif
 
     /* metacity_theme can be NULL only in one case - if user has disabled
      * metacity theme with use-metacity-theme setting. In that case
@@ -928,7 +739,6 @@ setup_theme (GWDThemeMetacity *metacity)
      */
     g_assert (metacity_theme_name != NULL);
 
-#ifdef HAVE_METACITY_3_20_0
     if (metacity_theme_type == -1)
         metacity_theme_type = META_THEME_TYPE_METACITY;
 
@@ -943,25 +753,6 @@ setup_theme (GWDThemeMetacity *metacity)
 
         return FALSE;
     }
-#else
-
-    /* meta_theme_get_current returns the last good theme, so we will try to
-     * load theme manually to know that theme is 100% valid.
-     */
-    theme = meta_theme_load (metacity_theme_name, NULL);
-    if (theme == NULL)
-        return FALSE;
-
-    /* We can not use this manually loaded theme because Metacity internaly
-     * also use meta_theme_get_current wich in this case will return NULL,
-     * boom - segfault...
-     */
-    meta_theme_free (theme);
-
-    /* If we are here then we know that this will not fail. */
-    meta_theme_set_current (metacity_theme_name, TRUE);
-    metacity->theme = meta_theme_get_current ();
-#endif
 
     return TRUE;
 }
@@ -997,11 +788,7 @@ gwd_theme_metacity_dispose (GObject *obj
 {
     GWDThemeMetacity *metacity = GWD_THEME_METACITY (object);
 
-#ifdef HAVE_METACITY_3_20_0
     g_clear_object (&metacity->theme);
-#else
-    g_clear_pointer (&metacity->style_variants, g_hash_table_destroy);
-#endif
 
     if (metacity->button_layout_id != 0) {
         GWDSettings *settings = gwd_theme_get_settings (GWD_THEME (metacity));
@@ -1010,10 +797,6 @@ gwd_theme_metacity_dispose (GObject *obj
         metacity->button_layout_id = 0;
     }
 
-#ifndef HAVE_METACITY_3_20_0
-    metacity->titlebar_font = NULL;
-#endif
-
     G_OBJECT_CLASS (gwd_theme_metacity_parent_class)->dispose (object);
 }
 
@@ -1022,11 +805,7 @@ gwd_theme_metacity_style_updated (GWDThe
 {
     GWDThemeMetacity *metacity = GWD_THEME_METACITY (theme);
 
-#ifdef HAVE_METACITY_3_20_0
     meta_theme_invalidate (metacity->theme);
-#else
-    g_hash_table_remove_all (metacity->style_variants);
-#endif
 }
 
 static void
@@ -1034,32 +813,28 @@ gwd_theme_metacity_draw_window_decoratio
                                            decor_t  *decor)
 {
     GWDThemeMetacity *metacity = GWD_THEME_METACITY (theme);
-    GWDSettings *settings = gwd_theme_get_settings (gwd_theme);
+    GWDSettings *settings = gwd_theme_get_settings (theme);
     GdkDisplay *display = gdk_display_get_default ();
     Display *xdisplay = gdk_x11_display_get_xdisplay (display);
     GtkWidget *style_window = gwd_theme_get_style_window (theme);
-#ifndef HAVE_METACITY_3_20_0
-    MetaStyleInfo *style_info = get_style_info (metacity, decor);
-    GtkStyleContext *context = gtk_widget_get_style_context (style_window);
-#endif
     cairo_surface_t *surface;
     Picture src;
+#ifndef HAVE_METACITY_3_22_0
     MetaButtonState button_states [META_BUTTON_TYPE_LAST];
+#endif
     MetaFrameGeometry fgeom;
     MetaFrameFlags flags;
     MetaFrameType frame_type;
     cairo_t *cr;
+#ifndef HAVE_METACITY_3_22_0
     gint i;
+#endif
     Region top_region;
     Region bottom_region;
     Region left_region;
     Region right_region;
     double alpha;
     gboolean shade_alpha;
-#ifndef HAVE_METACITY_3_20_0
-    MetaFrameStyle *frame_style;
-    GdkRGBA bg_rgba;
-#endif
 
     if (!decor->surface || !decor->picture)
         return;
@@ -1088,24 +863,14 @@ gwd_theme_metacity_draw_window_decoratio
 
     get_decoration_geometry (metacity, decor, &flags, &fgeom, frame_type);
 
-    if (decor->prop_xid || !decor->buffer_surface)
+    if (!decor->frame->has_shadow_extents &&
+        (decor->prop_xid || !decor->buffer_surface)) {
         draw_shadow_background (decor, cr, decor->shadow, decor->context);
+    }
 
+#ifndef HAVE_METACITY_3_22_0
     for (i = 0; i < META_BUTTON_TYPE_LAST; ++i)
         button_states[i] = meta_button_state_for_button_type (metacity, decor, i);
-
-#ifndef HAVE_METACITY_3_20_0
-    frame_style = meta_theme_get_frame_style (metacity->theme, frame_type, flags);
-
-    gtk_style_context_get_background_color (context, GTK_STATE_FLAG_NORMAL, &bg_rgba);
-    bg_rgba.alpha = 1.0;
-
-    if (frame_style->window_background_color) {
-        meta_color_spec_render (frame_style->window_background_color,
-                                context, &bg_rgba);
-
-        bg_rgba.alpha = frame_style->window_background_alpha / 255.0;
-    }
 #endif
 
     /* Draw something that will be almost invisible to user. This is hacky way
@@ -1118,67 +883,59 @@ gwd_theme_metacity_draw_window_decoratio
     cairo_destroy (cr);
 
     surface = create_surface (fgeom.width, fgeom.height, style_window);
-
     cr = cairo_create (surface);
 
-#ifndef HAVE_METACITY_3_20_0
-    gdk_cairo_set_source_rgba (cr, &bg_rgba);
-    cairo_set_operator (cr, CAIRO_OPERATOR_OVER);
-    cairo_paint (cr);
-#endif
-
     src = XRenderCreatePicture (xdisplay, cairo_xlib_surface_get_drawable (surface),
                                 xformat_rgba, 0, NULL);
 
-#ifdef HAVE_METACITY_3_20_0
+#ifdef HAVE_METACITY_3_22_0
     meta_theme_draw_frame (metacity->theme, decor->gtk_theme_variant, cr, frame_type, flags,
                            fgeom.width - fgeom.borders.total.left - fgeom.borders.total.right,
                            fgeom.height - fgeom.borders.total.top - fgeom.borders.total.bottom,
-                           decor->name, &metacity->button_layout,
-                           button_states, decor->icon_pixbuf, NULL);
+                           decor->name, update_button_state, decor, decor->icon_pixbuf, NULL);
 #else
-    meta_theme_draw_frame (metacity->theme, style_info, cr, frame_type, flags,
+    meta_theme_draw_frame (metacity->theme, decor->gtk_theme_variant, cr, frame_type, flags,
                            fgeom.width - fgeom.borders.total.left - fgeom.borders.total.right,
                            fgeom.height - fgeom.borders.total.top - fgeom.borders.total.bottom,
-                           decor->layout, decor->frame->text_height, &metacity->button_layout,
+                           decor->name, &metacity->button_layout,
                            button_states, decor->icon_pixbuf, NULL);
 #endif
 
-    if (fgeom.borders.visible.top) {
-        top_region = get_top_border_region (&fgeom, fgeom.width);
+    if (fgeom.borders.visible.top + fgeom.borders.shadow.top) {
+        top_region = get_top_border_region (&fgeom, !decor->frame->has_shadow_extents);
 
         decor_blend_border_picture (xdisplay, decor->context, src,
-                                    fgeom.borders.invisible.left,
-                                    fgeom.borders.invisible.top,
+                                    fgeom.borders.invisible.left - fgeom.borders.shadow.left,
+                                    fgeom.borders.invisible.top - fgeom.borders.shadow.top,
                                     decor->picture, &decor->border_layout,
                                     BORDER_TOP, top_region,
                                     alpha * 0xffff, shade_alpha, 0);
     }
 
-    if (fgeom.borders.visible.bottom) {
-        bottom_region = get_bottom_border_region (&fgeom, fgeom.width);
+    if (fgeom.borders.visible.bottom + fgeom.borders.shadow.bottom) {
+        bottom_region = get_bottom_border_region (&fgeom, !decor->frame->has_shadow_extents);
 
         decor_blend_border_picture (xdisplay, decor->context, src,
-                                    fgeom.borders.invisible.left,
+                                    fgeom.borders.invisible.left - fgeom.borders.shadow.left,
                                     fgeom.height - fgeom.borders.total.bottom,
                                     decor->picture, &decor->border_layout,
                                     BORDER_BOTTOM, bottom_region,
                                     alpha * 0xffff, shade_alpha, 0);
     }
 
-    if (fgeom.borders.visible.left) {
-        left_region = get_left_border_region (&fgeom, fgeom.height);
+    if (fgeom.borders.visible.left + fgeom.borders.shadow.left) {
+        left_region = get_left_border_region (&fgeom);
 
         decor_blend_border_picture (xdisplay, decor->context, src,
-                                    fgeom.borders.invisible.left,
+                                    fgeom.borders.invisible.left - fgeom.borders.shadow.left,
                                     fgeom.borders.total.top,
                                     decor->picture, &decor->border_layout,
                                     BORDER_LEFT, left_region,
                                     alpha * 0xffff, shade_alpha, 0);
     }
 
-    if (fgeom.borders.visible.right) {
-        right_region = get_right_border_region (&fgeom, fgeom.height);
+    if (fgeom.borders.visible.right + fgeom.borders.shadow.right) {
+        right_region = get_right_border_region (&fgeom);
 
         decor_blend_border_picture (xdisplay, decor->context, src,
                                     fgeom.width - fgeom.borders.total.right,
@@ -1278,40 +1035,39 @@ gwd_theme_metacity_update_border_extents
                                           decor_frame_t *frame)
 {
     GWDThemeMetacity *metacity = GWD_THEME_METACITY (theme);
-#ifndef HAVE_METACITY_3_20_0
-    MetaStyleInfo *style_info = get_style_info (metacity, NULL);
-#endif
+    GWDSettings *settings = gwd_theme_get_settings (theme);
+    gint theme_type = gwd_settings_get_metacity_theme_type (settings);
     MetaFrameType frame_type = frame_type_from_string (frame->type);
     MetaFrameBorders borders;
 
     gwd_decor_frame_ref (frame);
 
-#ifdef HAVE_METACITY_3_20_0
+    /* Shadow extents is used only with GTK+ theme */
+    frame->has_shadow_extents = theme_type == META_THEME_TYPE_GTK;
+
     meta_theme_get_frame_borders (metacity->theme, NULL, frame_type,
                                   0, &borders);
-#else
-    meta_theme_get_frame_borders (metacity->theme, style_info, frame_type,
-                                  frame->text_height, 0, &borders);
-#endif
 
     frame->win_extents.top = borders.visible.top;
     frame->win_extents.bottom = borders.visible.bottom;
     frame->win_extents.left = borders.visible.left;
     frame->win_extents.right = borders.visible.right;
+    frame->shadow_extents.top = borders.shadow.top;
+    frame->shadow_extents.bottom = borders.shadow.bottom;
+    frame->shadow_extents.left = borders.shadow.left;
+    frame->shadow_extents.right = borders.shadow.right;
 
-#ifdef HAVE_METACITY_3_20_0
     meta_theme_get_frame_borders (metacity->theme, NULL, frame_type,
                                   META_FRAME_MAXIMIZED, &borders);
-#else
-    meta_theme_get_frame_borders (metacity->theme, style_info, frame_type,
-                                  frame->text_height, META_FRAME_MAXIMIZED,
-                                  &borders);
-#endif
 
     frame->max_win_extents.top = borders.visible.top;
     frame->max_win_extents.bottom = borders.visible.bottom;
     frame->max_win_extents.left = borders.visible.left;
     frame->max_win_extents.right = borders.visible.right;
+    frame->max_shadow_extents.top = borders.shadow.top;
+    frame->max_shadow_extents.bottom = borders.shadow.bottom;
+    frame->max_shadow_extents.left = borders.shadow.left;
+    frame->max_shadow_extents.right = borders.shadow.right;
 
     gwd_decor_frame_unref (frame);
 }
@@ -1331,12 +1087,30 @@ gwd_theme_metacity_get_event_window_posi
     GWDThemeMetacity *metacity = GWD_THEME_METACITY (theme);
     MetaFrameGeometry fgeom;
     MetaFrameFlags flags;
+    GtkBorder visible;
+    GtkBorder resize;
+    GtkBorder total;
+    gint top_border;
 
     get_decoration_geometry (metacity, decor, &flags, &fgeom,
                              frame_type_from_string (decor->frame->type));
 
-    width += fgeom.borders.total.right + fgeom.borders.total.left;
-    height += fgeom.borders.total.top  + fgeom.borders.total.bottom;
+    visible = fgeom.borders.visible;
+    resize = fgeom.borders.resize;
+
+    /* We can not use `fgeom->borders.total` border here - it includes also
+     * `shadow` border, but it is not included in frame extents! Create new
+     * `total` border that includes only `visible` border and `resize` border.
+     */
+    total.left = visible.left + resize.left;
+    total.right = visible.right + resize.right;
+    total.top = visible.top + resize.top;
+    total.bottom = visible.bottom + resize.bottom;
+
+    width += total.left + total.right;
+    height += total.top + total.bottom;
+
+    top_border = fgeom.title_rect.y - fgeom.borders.invisible.top;
 
 #define TOP_RESIZE_HEIGHT 2
 #define RESIZE_EXTENDS 15
@@ -1345,51 +1119,51 @@ gwd_theme_metacity_get_event_window_posi
         case 2: /* bottom */
             switch (j) {
                 case 2: /* bottom right */
-                    *x = width - fgeom.borders.total.right - RESIZE_EXTENDS;
-                    *y = height - fgeom.borders.total.bottom - RESIZE_EXTENDS;
+                    *x = width - total.right - RESIZE_EXTENDS;
+                    *y = height - total.bottom - RESIZE_EXTENDS;
 
-                    *w = fgeom.borders.total.right + RESIZE_EXTENDS;
-                    *h = fgeom.borders.total.bottom + RESIZE_EXTENDS;
+                    *w = total.right + RESIZE_EXTENDS;
+                    *h = total.bottom + RESIZE_EXTENDS;
                     break;
                 case 1: /* bottom */
-                    *x = fgeom.borders.total.left + RESIZE_EXTENDS;
-                    *y = height - fgeom.borders.total.bottom;
+                    *x = total.left + RESIZE_EXTENDS;
+                    *y = height - total.bottom;
 
-                    *w = width - fgeom.borders.total.left - fgeom.borders.total.right - (2 * RESIZE_EXTENDS);
-                    *h = fgeom.borders.total.bottom;
+                    *w = width - total.left - total.right - (2 * RESIZE_EXTENDS);
+                    *h = total.bottom;
                     break;
                 case 0: /* bottom left */
                 default:
                     *x = 0;
-                    *y = height - fgeom.borders.total.bottom - RESIZE_EXTENDS;
+                    *y = height - total.bottom - RESIZE_EXTENDS;
 
-                    *w = fgeom.borders.total.left + RESIZE_EXTENDS;
-                    *h = fgeom.borders.total.bottom + RESIZE_EXTENDS;
+                    *w = total.left + RESIZE_EXTENDS;
+                    *h = total.bottom + RESIZE_EXTENDS;
                     break;
             }
             break;
         case 1: /* middle */
             switch (j) {
                 case 2: /* right */
-                    *x = width - fgeom.borders.total.right;
-                    *y = fgeom.borders.total.top + RESIZE_EXTENDS;
+                    *x = width - total.right;
+                    *y = resize.top + top_border + RESIZE_EXTENDS;
 
-                    *w = fgeom.borders.total.right;
-                    *h = height - fgeom.borders.total.top - fgeom.borders.total.bottom - (2 * RESIZE_EXTENDS);
+                    *w = total.right;
+                    *h = height - resize.top - top_border - total.bottom - (2 * RESIZE_EXTENDS);
                     break;
                 case 1: /* middle */
-                    *x = fgeom.borders.total.left;
-                    *y = fgeom.title_rect.y + TOP_RESIZE_HEIGHT;
-                    *w = width - fgeom.borders.total.left - fgeom.borders.total.right;
-                    *h = height - fgeom.borders.total.top - fgeom.borders.total.bottom;
+                    *x = total.left;
+                    *y = resize.top + top_border + TOP_RESIZE_HEIGHT;
+                    *w = width - total.left - total.right;
+                    *h = visible.top - top_border - TOP_RESIZE_HEIGHT;
                     break;
                 case 0: /* left */
                 default:
                     *x = 0;
-                    *y = fgeom.borders.total.top + RESIZE_EXTENDS;
+                    *y = resize.top + top_border + RESIZE_EXTENDS;
 
-                    *w = fgeom.borders.total.left;
-                    *h = height - fgeom.borders.total.top - fgeom.borders.total.bottom - (2 * RESIZE_EXTENDS);
+                    *w = total.left;
+                    *h = height - resize.top - top_border - total.bottom - (2 * RESIZE_EXTENDS);
                     break;
             }
             break;
@@ -1397,26 +1171,26 @@ gwd_theme_metacity_get_event_window_posi
         default:
             switch (j) {
                 case 2: /* top right */
-                    *x = width - fgeom.borders.total.right - RESIZE_EXTENDS;
+                    *x = width - total.right - RESIZE_EXTENDS;
                     *y = 0;
 
-                    *w = fgeom.borders.total.right + RESIZE_EXTENDS;
-                    *h = fgeom.borders.total.top + RESIZE_EXTENDS;
+                    *w = total.right + RESIZE_EXTENDS;
+                    *h = resize.top + top_border + RESIZE_EXTENDS;
                     break;
                 case 1: /* top */
-                    *x = fgeom.borders.total.left + RESIZE_EXTENDS;
+                    *x = total.left + RESIZE_EXTENDS;
                     *y = 0;
 
-                    *w = width - fgeom.borders.total.left - fgeom.borders.total.right - (2 * RESIZE_EXTENDS);
-                    *h = fgeom.borders.total.top - fgeom.title_rect.height;
+                    *w = width - total.left - total.right - (2 * RESIZE_EXTENDS);
+                    *h = resize.top + top_border + TOP_RESIZE_HEIGHT;
                     break;
                 case 0: /* top left */
                 default:
                     *x = 0;
                     *y = 0;
 
-                    *w = fgeom.borders.total.left + RESIZE_EXTENDS;
-                    *h = fgeom.borders.total.top + RESIZE_EXTENDS;
+                    *w = total.left + RESIZE_EXTENDS;
+                    *h = resize.top + top_border + RESIZE_EXTENDS;
                     break;
             }
             break;
@@ -1453,8 +1227,14 @@ gwd_theme_metacity_get_button_position (
     MetaFrameGeometry fgeom;
     MetaFrameType frame_type;
     MetaFrameFlags flags;
+#ifdef HAVE_METACITY_3_22_0
+    MetaButtonType button_type;
+    MetaButton **buttons;
+    gint index;
+#else
     MetaButtonFunction button_function;
     MetaButtonSpace *space;
+#endif
 
     if (!decor->context) {
         /* undecorated windows implicitly have no buttons */
@@ -1465,6 +1245,34 @@ gwd_theme_metacity_get_button_position (
 
     get_decoration_geometry (metacity, decor, &flags, &fgeom, frame_type);
 
+#ifdef HAVE_METACITY_3_22_0
+    button_type = button_to_meta_button_type (i);
+    buttons = meta_theme_get_buttons (metacity->theme);
+
+    for (index = 0; buttons[index]; index++) {
+        if (meta_button_get_type (buttons[index]) == button_type) {
+            GdkRectangle rect;
+
+            meta_button_get_event_rect (buttons[index], &rect);
+
+            if (rect.width != 0 && rect.height != 0) {
+                *x = rect.x;
+                *y = rect.y;
+                *w = rect.width;
+                *h = rect.height;
+
+                *x = *x - fgeom.borders.invisible.left + fgeom.borders.resize.left;
+                *y = *y - fgeom.borders.invisible.top + fgeom.borders.resize.top;
+
+                g_free (buttons);
+                return TRUE;
+            }
+        }
+    }
+
+    g_free (buttons);
+    return FALSE;
+#else
     button_function = button_to_meta_button_function (i);
     if (!button_present (metacity, button_function))
         return FALSE;
@@ -1512,7 +1320,11 @@ gwd_theme_metacity_get_button_position (
     *w = space->clickable.width;
     *h = space->clickable.height;
 
+    *x = *x - fgeom.borders.invisible.left + fgeom.borders.resize.left;
+    *y = *y - fgeom.borders.invisible.top + fgeom.borders.resize.top;
+
     return TRUE;
+#endif
 }
 
 static void
@@ -1521,32 +1333,7 @@ gwd_theme_metacity_update_titlebar_font
 {
     GWDThemeMetacity *metacity = GWD_THEME_METACITY (theme);
 
-#ifdef HAVE_METACITY_3_20_0
     meta_theme_set_titlebar_font (metacity->theme, titlebar_font);
-#else
-    metacity->titlebar_font = titlebar_font;
-#endif
-}
-
-static PangoFontDescription *
-gwd_theme_metacity_get_titlebar_font (GWDTheme      *theme,
-                                      decor_frame_t *frame)
-{
-#ifdef HAVE_METACITY_3_20_0
-    return NULL;
-#else
-    GWDThemeMetacity *metacity = GWD_THEME_METACITY (theme);
-    MetaStyleInfo *style_info = get_style_info (metacity, NULL);
-    PangoFontDescription *font_desc = meta_style_info_create_font_desc (style_info);
-    MetaFrameType type = frame_type_from_string (frame->type);
-    MetaFrameFlags flags = 0xc33; /* FIXME */
-    MetaFrameStyle *style = meta_theme_get_frame_style (metacity->theme, type, flags);
-
-    pango_font_description_merge (font_desc, metacity->titlebar_font, TRUE);
-    meta_frame_style_apply_scale (style, font_desc);
-
-    return font_desc;
-#endif
 }
 
 static void
@@ -1565,16 +1352,11 @@ gwd_theme_metacity_class_init (GWDThemeM
     theme_class->get_event_window_position = gwd_theme_metacity_get_event_window_position;
     theme_class->get_button_position = gwd_theme_metacity_get_button_position;
     theme_class->update_titlebar_font = gwd_theme_metacity_update_titlebar_font;
-    theme_class->get_titlebar_font = gwd_theme_metacity_get_titlebar_font;
 }
 
 static void
 gwd_theme_metacity_init (GWDThemeMetacity *metacity)
 {
-#ifndef HAVE_METACITY_3_20_0
-    metacity->style_variants = g_hash_table_new_full (g_str_hash, g_str_equal, g_free,
-                                                      (GDestroyNotify) meta_style_info_unref);
-#endif
 }
 
 /**
diff -Npur compiz-0.9.13.0.orig/plugins/animationjc/animationjc.xml.in compiz-0.9.13.0/plugins/animationjc/animationjc.xml.in
--- compiz-0.9.13.0.orig/plugins/animationjc/animationjc.xml.in	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/animationjc/animationjc.xml.in	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,154 @@
+<compiz>
+  <!-- animationaddon metadata -->
+  <plugin name="animationjc" useBcop="true">
+    <_short>Animations Experimental</_short>
+    <_long>Extra window animations</_long>
+    <category>Effects</category>
+    <deps>
+      <requirement>
+	<plugin>opengl</plugin>
+	<plugin>animation</plugin>
+      </requirement>
+      <relation type="after">
+	<plugin>opengl</plugin>
+	<plugin>composite</plugin>
+	<plugin>animation</plugin>
+	<plugin>decor</plugin>
+      </relation>
+    </deps>
+
+    <options>
+    <group>
+      <_short>Effect Settings</_short>
+
+      <subgroup>
+        <_short>Black Hole</_short>
+	<option name="blackhole_delay" type="float">
+	  <_short>Delay</_short>
+	  <default>0.75</default>
+	  <min>0.0</min>
+	  <max>0.99</max>
+	  <precision>0.01</precision>
+	</option>
+      </subgroup>
+
+      <subgroup>
+        <_short>Flicker</_short>
+	<option name="flicker_amplitude" type="int">
+	  <_short>Amplitude</_short>
+	  <default>3</default>
+	  <min>1</min>
+	  <max>10</max>
+	</option>
+      </subgroup>
+
+      <subgroup>
+        <_short>Ghost</_short>
+	<option name="ghost_grid" type="int">
+	  <_short>Grid</_short>
+	  <default>20</default>
+	  <min>2</min>
+	  <max>20</max>
+	</option>
+
+	<option name="ghost_saturation" type="float">
+	  <_short>Saturation</_short>
+	  <default>0.0</default>
+	  <min>0.0</min>
+	  <max>1.0</max>
+	  <precision>0.1</precision>
+	</option>
+
+	<option name="ghost_amplitude" type="float">
+	  <_short>Amplitude</_short>
+	  <default>1.0</default>
+	  <min>0.0</min>
+	  <max>5.0</max>
+	</option>
+
+	<option name="ghost_wave_speed" type="float">
+	  <_short>Wave Speed</_short>
+	  <default>1.0</default>
+	  <min>0.0</min>
+	  <max>5.0</max>
+	</option>
+      </subgroup>
+
+      <subgroup>
+        <_short>Popcorn</_short>
+	<option name="popcorn_kernel_height" type="float">
+	  <_short>Kernel Height</_short>
+	  <default>1.0</default>
+	  <min>0.0</min>
+	  <max>5.0</max>
+	  <precision>0.1</precision>
+	</option>
+      </subgroup>
+
+      <subgroup>
+        <_short>Raindrop</_short>
+
+	<option name="raindrop_amplitude" type="float">
+	  <_short>Amplitude</_short>
+	  <default>1.0</default>
+	  <min>-5.0</min>
+	  <max>5.0</max>
+	  <precision>0.1</precision>
+	</option>
+
+	<option name="raindrop_wavelength" type="float">
+	  <_short>Wavelength</_short>
+	  <default>0.4</default>
+	  <min>0.0</min>
+	  <max>1.0</max>
+	  <precision>0.05</precision>
+	</option>
+
+	<option name="raindrop_num_waves" type="int">
+	  <_short>Number of Waves</_short>
+	  <default>1</default>
+	  <min>1</min>
+	  <max>5</max>
+	</option>
+      </subgroup>
+    </group>
+    </options>
+
+    <extension base_plugin="animation">
+      <base_option>open_effects</base_option>
+      <base_option>open_random_effects</base_option>
+      <base_option>close_effects</base_option>
+      <base_option>close_random_effects</base_option>
+      <base_option>minimize_effects</base_option>
+      <base_option>minimize_random_effects</base_option>
+      <restriction>
+        <value>animationjc:Black Hole</value>
+        <_name>Black Hole</_name>
+      </restriction>
+      <restriction>
+        <value>animationjc:Ghost</value>
+        <_name>Ghost</_name>
+      </restriction>
+      <restriction>
+        <value>animationjc:Popcorn</value>
+        <_name>Popcorn</_name>
+      </restriction>
+    </extension>
+
+    <extension base_plugin="animation">
+      <base_option>open_effects</base_option>
+      <base_option>open_random_effects</base_option>
+      <base_option>close_effects</base_option>
+      <base_option>close_random_effects</base_option>
+      <base_option>focus_effects</base_option>
+      <restriction>
+        <value>animationjc:Flicker</value>
+        <_name>Flicker</_name>
+      </restriction>
+      <restriction>
+        <value>animationjc:Raindrop</value>
+        <_name>Raindrop</_name>
+      </restriction>
+    </extension>
+  </plugin>
+</compiz>
diff -Npur compiz-0.9.13.0.orig/plugins/animationjc/CMakeLists.txt compiz-0.9.13.0/plugins/animationjc/CMakeLists.txt
--- compiz-0.9.13.0.orig/plugins/animationjc/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/animationjc/CMakeLists.txt	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,4 @@
+find_package (Compiz REQUIRED)
+include (CompizPlugin)
+
+compiz_plugin (animationjc PLUGINDEPS composite opengl animation)
diff -Npur compiz-0.9.13.0.orig/plugins/animationjc/compiz-animationjc.pc.in compiz-0.9.13.0/plugins/animationjc/compiz-animationjc.pc.in
--- compiz-0.9.13.0.orig/plugins/animationjc/compiz-animationjc.pc.in	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/animationjc/compiz-animationjc.pc.in	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,12 @@
+prefix=@prefix@
+exec_prefix=@prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: compiz-animationjc
+Description: Animation JC plugin for compiz
+Version: @VERSION@
+
+Requires: compiz compiz-composite compiz-opengl compiz-animation
+Libs: -L${libdir} -lanimationjc
+Cflags: @COMPIZ_CFLAGS@
diff -Npur compiz-0.9.13.0.orig/plugins/animationjc/include/animationjc/animationjc.h compiz-0.9.13.0/plugins/animationjc/include/animationjc/animationjc.h
--- compiz-0.9.13.0.orig/plugins/animationjc/include/animationjc/animationjc.h	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/animationjc/include/animationjc/animationjc.h	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,42 @@
+#ifndef _COMPIZ_ANIMATIONJC_H
+#define _COMPIZ_ANIMATIONJC_H
+
+#define ANIMATIONADDON_ABI 20091206
+
+#include <core/pluginclasshandler.h>
+
+#include <vector>
+#include <boost/ptr_container/ptr_vector.hpp>
+
+#include <opengl/opengl.h>
+
+using namespace::std;
+
+class PrivateAnimJCScreen;
+
+
+/// Base class for all polygon- and particle-based animations
+class BaseAddonAnim :
+    virtual public Animation
+{
+public:
+    BaseAddonAnim (CompWindow *w,
+		   WindowEvent curWindowEvent,
+		   float duration,
+		   const AnimEffect info,
+		   const CompRect &icon);
+    ~BaseAddonAnim () {}
+
+    bool needsDepthTest () { return mDoDepthTest; }
+
+protected:
+    /// Gets info about the extension plugin that implements this animation.
+    ExtensionPluginInfo *getExtensionPluginInfo ();
+
+    CompositeScreen *mCScreen;
+    GLScreen *mGScreen;
+
+    bool mDoDepthTest;  ///< Whether depth testing should be used in the effect
+};
+
+#endif
diff -Npur compiz-0.9.13.0.orig/plugins/animationjc/src/animationjc.cpp compiz-0.9.13.0/plugins/animationjc/src/animationjc.cpp
--- compiz-0.9.13.0.orig/plugins/animationjc/src/animationjc.cpp	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/animationjc/src/animationjc.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,150 @@
+#include "private.h"
+
+class AnimJCPluginVTable :
+    public CompPlugin::VTableForScreenAndWindow<AnimJCScreen, AnimJCWindow>
+{
+public:
+    bool init ();
+};
+
+COMPIZ_PLUGIN_20090315 (animationjc, AnimJCPluginVTable);
+
+AnimEffect animEffects[NUM_EFFECTS];
+
+ExtensionPluginAnimJC animJCExtPluginInfo (CompString ("animationjc"),
+					   NUM_EFFECTS, animEffects, NULL,
+                                           NUM_NONEFFECT_OPTIONS);
+
+AnimEffect AnimEffectBlackHole;
+AnimEffect AnimEffectFlicker;
+AnimEffect AnimEffectGhost;
+AnimEffect AnimEffectPopcorn;
+AnimEffect AnimEffectRaindrop;
+
+ExtensionPluginInfo *
+BaseAddonAnim::getExtensionPluginInfo ()
+{
+    return &animJCExtPluginInfo;
+}
+
+BaseAddonAnim::BaseAddonAnim (CompWindow *w,
+			      WindowEvent curWindowEvent,
+			      float duration,
+			      const AnimEffect info,
+			      const CompRect &icon) :
+    Animation::Animation (w, curWindowEvent, duration, info, icon),
+    mCScreen (CompositeScreen::get (::screen)),
+    mGScreen (GLScreen::get (::screen)),
+    mDoDepthTest (false)
+{
+}
+
+void
+AnimJCScreen::initAnimationList ()
+{
+    int i = 0;
+
+    AnimEffectUsedFor focusableUsedFor = AnimEffectUsedFor::all ()
+					 .exclude (AnimEventShade);
+    AnimEffectUsedFor openUsedFor = AnimEffectUsedFor::all ()
+				    .exclude (AnimEventShade)
+				    .exclude (AnimEventFocus);
+
+    animEffects[i++] = AnimEffectBlackHole =
+        new AnimEffectInfo ("animationjc:Black Hole",
+			    openUsedFor,
+                            &createAnimation<BlackHoleAnim>);
+
+    animEffects[i++] = AnimEffectFlicker =
+        new AnimEffectInfo ("animationjc:Flicker",
+			    focusableUsedFor,
+                            &createAnimation<FlickerAnim>);
+
+    animEffects[i++] = AnimEffectGhost =
+        new AnimEffectInfo ("animationjc:Ghost",
+			    openUsedFor,
+                            &createAnimation<GhostAnim>);
+
+    animEffects[i++] = AnimEffectPopcorn =
+        new AnimEffectInfo ("animationjc:Popcorn",
+			    openUsedFor,
+                            &createAnimation<PopcornAnim>);
+
+    animEffects[i++] = AnimEffectRaindrop =
+        new AnimEffectInfo ("animationjc:Raindrop",
+			    focusableUsedFor,
+                            &createAnimation<RaindropAnim>);
+
+    animJCExtPluginInfo.effectOptions = &getOptions ();
+
+    AnimScreen *as = AnimScreen::get (::screen);
+
+    // Extends animation plugin with this set of animation effects.
+    as->addExtension (&animJCExtPluginInfo);
+}
+
+PrivateAnimJCScreen::PrivateAnimJCScreen (CompScreen *s) :
+    mOutput (s->fullscreenOutput ())
+{
+}
+
+PrivateAnimJCScreen::~PrivateAnimJCScreen ()
+{
+    AnimScreen *as = AnimScreen::get (::screen);
+
+    as->removeExtension (&animJCExtPluginInfo);
+
+    for (int i = 0; i < NUM_EFFECTS; i++)
+    {
+	delete animEffects[i];
+	animEffects[i] = NULL;
+    }
+}
+
+AnimJCScreen::AnimJCScreen (CompScreen *s) :
+    PluginClassHandler<AnimJCScreen, CompScreen> (s),
+    priv (new PrivateAnimJCScreen (s))
+{
+    initAnimationList ();
+}
+
+AnimJCScreen::~AnimJCScreen ()
+{
+    delete priv;
+}
+
+AnimJCWindow::AnimJCWindow (CompWindow *w) :
+    PluginClassHandler<AnimJCWindow, CompWindow> (w),
+    mWindow (w),
+    aWindow (AnimWindow::get (w))
+{
+}
+
+AnimJCWindow::~AnimJCWindow ()
+{
+    Animation *curAnim = aWindow->curAnimation ();
+
+    if (!curAnim)
+	return;
+
+    // We need to interrupt and clean up the animation currently being played
+    // by animationaddon for this window (if any)
+    if (curAnim->remainingTime () > 0 &&
+	curAnim->getExtensionPluginInfo ()->name ==
+	    CompString ("animationjc"))
+    {
+	aWindow->postAnimationCleanUp ();
+    }
+}
+
+bool
+AnimJCPluginVTable::init ()
+{
+    if (!CompPlugin::checkPluginABI ("core", CORE_ABIVERSION) |
+        !CompPlugin::checkPluginABI ("composite", COMPIZ_COMPOSITE_ABI) |
+        !CompPlugin::checkPluginABI ("opengl", COMPIZ_OPENGL_ABI) |
+        !CompPlugin::checkPluginABI ("animation", ANIMATION_ABI))
+	 return false;
+
+    return true;
+}
diff -Npur compiz-0.9.13.0.orig/plugins/animationjc/src/blackhole.cpp compiz-0.9.13.0/plugins/animationjc/src/blackhole.cpp
--- compiz-0.9.13.0.orig/plugins/animationjc/src/blackhole.cpp	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/animationjc/src/blackhole.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,79 @@
+#include "private.h"
+
+#include <algorithm>
+
+BlackHoleAnim::BlackHoleAnim (CompWindow *w,
+			      WindowEvent curWindowEvent,
+			      float duration,
+			      const AnimEffect info,
+			      const CompRect &icon) :
+    Animation::Animation (w, curWindowEvent, duration, info, icon),
+    TransformAnim::TransformAnim (w, curWindowEvent, duration, info, icon),
+    GridTransformAnim::GridTransformAnim (w, curWindowEvent, duration, info,
+                                          icon)
+{
+}
+
+void
+BlackHoleAnim::initGrid ()
+{
+    mGridWidth = 20;
+    mGridHeight = 20;
+}
+
+void
+BlackHoleAnim::step ()
+{
+    CompRect winRect (mAWindow->savedRectsValid () ?
+                      mAWindow->saveWinRect () :
+                      mWindow->geometry ());
+    CompRect outRect (mAWindow->savedRectsValid () ?
+                      mAWindow->savedOutRect () :
+                      mWindow->outputRect ());
+    CompWindowExtents outExtents (mAWindow->savedRectsValid () ?
+			          mAWindow->savedOutExtents () :
+			          mWindow->output ());
+
+    int wx = winRect.x ();
+    int wy = winRect.y ();
+
+    int owidth = outRect.width ();
+    int oheight = outRect.height ();
+
+    float centerx = wx + mModel->scale ().x () *
+	    (owidth * 0.5 - outExtents.left);
+    float centery = wy + mModel->scale ().y () *
+	    (oheight * 0.5 - outExtents.top);
+
+    float delay = AnimJCScreen::get (screen)->optionGetBlackholeDelay ();
+    float tau = (1. - delay) / 8.;
+
+    GridModel::GridObject *object = mModel->objects ();
+    unsigned int n = mModel->numObjects ();
+    for (unsigned int i = 0; i < n; i++, object++)
+    {
+	// find distance to center in grid terms, 0..1
+	float gridDistance = 2 * max (fabs (object->gridPosition ().x ()-0.5),
+				      fabs (object->gridPosition ().y ()-0.5));
+
+	// use that and tau to find r
+	float cutoff = gridDistance * delay;
+	float r = 1;
+	if (getBlackHoleProgress () > cutoff)
+	    r = exp (-(getBlackHoleProgress () - cutoff) / tau);
+
+	// find real original coordinates
+	float origx = wx + mModel->scale ().x () *
+		(owidth * object->gridPosition ().x () -
+		outExtents.left);
+	float origy = wy + mModel->scale ().y () *
+                (oheight * object->gridPosition ().y () -
+                outExtents.top);
+
+	// shrink toward center by r
+	Point3d &objPos = object->position ();
+	objPos.setX ((origx-centerx) * r + centerx);
+	objPos.setY ((origy-centery) * r + centery);
+	objPos.setZ (0);
+    }
+}
diff -Npur compiz-0.9.13.0.orig/plugins/animationjc/src/flicker.cpp compiz-0.9.13.0/plugins/animationjc/src/flicker.cpp
--- compiz-0.9.13.0.orig/plugins/animationjc/src/flicker.cpp	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/animationjc/src/flicker.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,96 @@
+#include <private.h>
+
+void
+FlickerSingleAnim::updateAttrib (GLWindowPaintAttrib &attrib)
+{
+    int layer = MultiAnim <FlickerSingleAnim,5>::getCurrAnimNumber (mAWindow);
+    float o = 0.2;
+    attrib.opacity *= o / (1. - (4-layer)*o);
+}
+
+void
+FlickerSingleAnim::initGrid ()
+{
+    mGridWidth = 2;
+    mGridHeight = 20;
+}
+
+void
+FlickerSingleAnim::step ()
+{
+    int layer = MultiAnim <FlickerSingleAnim,5>::getCurrAnimNumber (mAWindow);
+
+    CompRect winRect (mAWindow->savedRectsValid () ?
+                      mAWindow->saveWinRect () :
+                      mWindow->geometry ());
+    CompRect outRect (mAWindow->savedRectsValid () ?
+                      mAWindow->savedOutRect () :
+                      mWindow->outputRect ());
+    CompWindowExtents outExtents (mAWindow->savedRectsValid () ?
+                                  mAWindow->savedOutExtents () :
+                                  mWindow->output ());
+
+    int wx = winRect.x ();
+    int wy = winRect.y ();
+    int owidth = outRect.width ();
+    int oheight = outRect.height ();
+
+    float t = 1 - progressLinear ();
+    if (mCurWindowEvent == WindowEventClose)
+	t = 1 - t;
+
+    float amplitude = AnimJCScreen::get (screen)->optionGetFlickerAmplitude ();
+    float waveLength = 0.4;
+    float wavePosition = -waveLength + (1. + waveLength) * t;
+
+    float displacement = 0;
+
+    GridModel::GridObject *object = mModel->objects ();
+    unsigned int n = mModel->numObjects ();
+    for (unsigned int i = 0; i < n; i++, object++)
+    {
+	Point3d &objPos = object->position ();
+
+	if (i % 2 == 0) // left side; reuse old displacement on right side
+	{
+	    float distFromWave = object->gridPosition ().y () - wavePosition;
+
+	    if (distFromWave > 0 && distFromWave <= waveLength)
+	    {
+		displacement = amplitude * sin (distFromWave/waveLength * M_PI);
+	    }
+	    else
+	    {
+		displacement = 0;
+	    }
+	}
+
+        float x = wx + mModel->scale ().x () *
+            (owidth * object->gridPosition ().x () - outExtents.left);
+
+	float y = wy + mModel->scale ().y () *
+	    (oheight * object->gridPosition ().y () - outExtents.top);
+
+	switch (layer)
+	{
+	    case 1:
+		x -= displacement;
+		break;
+	    case 2:
+		x += displacement;
+		break;
+	    case 3:
+		y -= displacement;
+		break;
+	    case 4:
+		y += displacement;
+		break;
+	    default:
+		break;
+	}
+
+        objPos.setX (x);
+	objPos.setY (y);
+	objPos.setZ (0);
+    }
+}
diff -Npur compiz-0.9.13.0.orig/plugins/animationjc/src/ghost.cpp compiz-0.9.13.0/plugins/animationjc/src/ghost.cpp
--- compiz-0.9.13.0.orig/plugins/animationjc/src/ghost.cpp	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/animationjc/src/ghost.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,98 @@
+#include "private.h"
+
+GhostAnim::GhostAnim (CompWindow *w,
+		      WindowEvent curWindowEvent,
+		      float duration,
+		      const AnimEffect info,
+		      const CompRect &icon) :
+    Animation::Animation (w, curWindowEvent, duration, info, icon),
+    TransformAnim::TransformAnim (w, curWindowEvent, duration, info, icon),
+    GridTransformAnim::GridTransformAnim (w, curWindowEvent, duration, info,
+                                          icon)
+{
+}
+
+void
+GhostAnim::updateAttrib (GLWindowPaintAttrib &attrib)
+{
+    AnimJCScreen *ajs = AnimJCScreen::get (screen);
+    attrib.opacity *= 1. - progressLinear ();
+    attrib.saturation *= ajs->optionGetGhostSaturation ();
+}
+
+void
+GhostAnim::initGrid ()
+{
+    AnimJCScreen *ajs = AnimJCScreen::get (screen);
+    mGridWidth = ajs->optionGetGhostGrid ();
+    mGridHeight = ajs->optionGetGhostGrid ();
+}
+
+void
+GhostAnim::step ()
+{
+    float t = 1. - progressLinear ();
+    if (mCurWindowEvent == WindowEventClose)
+	t = 1. - t;
+
+    CompRect winRect (mAWindow->savedRectsValid () ?
+                      mAWindow->saveWinRect () :
+                      mWindow->geometry ());
+    CompRect outRect (mAWindow->savedRectsValid () ?
+                      mAWindow->savedOutRect () :
+                      mWindow->outputRect ());
+    CompWindowExtents outExtents (mAWindow->savedRectsValid () ?
+			          mAWindow->savedOutExtents () :
+			          mWindow->output ());
+
+    int wx = winRect.x ();
+    int wy = winRect.y ();
+
+    int owidth = outRect.width ();
+    int oheight = outRect.height ();
+
+    AnimJCScreen *ajs = AnimJCScreen::get (screen);
+
+    float waveAmp = 3 * ajs->optionGetGhostAmplitude ();
+    float waveLengthX1 = 0.4;
+    float waveLengthX2 = 0.3;
+    float waveLengthY1 = 0.45;
+    float waveLengthY2 = 0.35;
+    float wavePositionX1 =  0.25 * t * ajs->optionGetGhostWaveSpeed ();
+    float wavePositionX2 = -0.25 * t * ajs->optionGetGhostWaveSpeed ();
+    float wavePositionY1 =  0.25 * t * ajs->optionGetGhostWaveSpeed ();
+    float wavePositionY2 = -0.25 * t * ajs->optionGetGhostWaveSpeed ();
+
+    GridModel::GridObject *object = mModel->objects ();
+    unsigned int n = mModel->numObjects ();
+    for (unsigned int i = 0; i < n; i++, object++)
+    {
+	Point3d &objPos = object->position ();
+
+	float origx = wx + mModel->scale ().x () *
+		(owidth * object->gridPosition ().x () -
+		outExtents.left);
+
+	float origy = wy + mModel->scale ().y () *
+		(oheight * object->gridPosition ().y () -
+		outExtents.top);
+
+	float x = object->gridPosition ().x ();
+	float y = object->gridPosition ().y ();
+
+	float distFromWaveX1 = x - wavePositionX1;
+	float distFromWaveX2 = x - wavePositionX2;
+	float distFromWaveY1 = y - wavePositionY1;
+	float distFromWaveY2 = y - wavePositionY2;
+
+	objPos.setX (origx +
+		     waveAmp * sin (distFromWaveX1 / waveLengthX1 * 2 * M_PI) +
+		     waveAmp * sin (distFromWaveX2 / waveLengthX2 * 2 * M_PI));
+
+	objPos.setY (origy +
+		     waveAmp * sin (distFromWaveY1 / waveLengthY1 * 2 * M_PI) +
+		     waveAmp * sin (distFromWaveY2 / waveLengthY2 * 2 * M_PI));
+
+	objPos.setZ (0);
+    }
+}
diff -Npur compiz-0.9.13.0.orig/plugins/animationjc/src/popcorn.cpp compiz-0.9.13.0/plugins/animationjc/src/popcorn.cpp
--- compiz-0.9.13.0.orig/plugins/animationjc/src/popcorn.cpp	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/animationjc/src/popcorn.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,60 @@
+#include <private.h>
+
+#define WIN_X(w) ((w)->x () - (w)->input ().left)
+#define WIN_Y(w) ((w)->y () - (w)->input ().top)
+#define WIN_W(w) ((w)->width () + (w)->input ().left + (w)->input ().right)
+#define WIN_H(w) ((w)->height () + (w)->input ().top + (w)->input ().bottom)
+
+float
+PopcornSingleAnim::layerProgress (int layer)
+{
+    if (layer == 0)
+	return 0;
+
+    float tStart = (5. - layer) / 6.;
+    float tEnd = tStart + 1./3.;
+
+    float t = progressLinear ();
+
+    if (t < tStart)
+	return 0;
+
+    if (t > tEnd)
+	return 1;
+
+    return (t - tStart) / (tEnd - tStart);
+}
+
+void
+PopcornSingleAnim::updateAttrib (GLWindowPaintAttrib &attrib)
+{
+    int layer = MultiAnim <PopcornSingleAnim, 6>::getCurrAnimNumber (mAWindow);
+
+    attrib.opacity *= 1. - progressLinear ();
+
+    attrib.opacity *= 1. - layerProgress (layer);
+}
+
+void
+PopcornSingleAnim::applyTransform ()
+{
+    int layer = MultiAnim <PopcornSingleAnim, 6>::getCurrAnimNumber (mAWindow);
+
+    if (layer == 0) return;
+
+    float p = layerProgress (layer);
+
+    float v = 40.;
+    float theta = (54. + 144.*(layer-1)) / 180. * 3.14159265;
+    float dx = v * cos (theta) * p;
+    float dy = -v * sin (theta) * p;
+
+    mTransform.translate (dx, dy,
+	    0.16*p*AnimJCScreen::get (screen)->optionGetPopcornKernelHeight ());
+}
+
+void
+PopcornSingleAnim::updateBB (CompOutput &output)
+{
+    TransformAnim::updateBB (output);
+}
diff -Npur compiz-0.9.13.0.orig/plugins/animationjc/src/private.h compiz-0.9.13.0/plugins/animationjc/src/private.h
--- compiz-0.9.13.0.orig/plugins/animationjc/src/private.h	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/animationjc/src/private.h	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,232 @@
+#include <string.h>
+#include <stdlib.h>
+#include <math.h>
+
+#include <core/core.h>
+#include <composite/composite.h>
+#include <opengl/opengl.h>
+
+#include <boost/foreach.hpp>
+#define foreach BOOST_FOREACH
+
+#include <animation/animation.h>
+#include <animationjc/animationjc.h>
+
+#include "animationjc_options.h"
+
+extern AnimEffect AnimEffectBlackHole;
+extern AnimEffect AnimEffectFlicker;
+extern AnimEffect AnimEffectGhost;
+extern AnimEffect AnimEffectPopcorn;
+extern AnimEffect AnimEffectRaindrop;
+
+#define NUM_EFFECTS 5
+
+// This must have the value of the first "effect setting" above
+// in AnimJCScreenOptions
+#define NUM_NONEFFECT_OPTIONS 0
+
+class ExtensionPluginAnimJC : public ExtensionPluginInfo
+{
+public:
+    ExtensionPluginAnimJC (const CompString &name,
+			      unsigned int nEffects,
+			      AnimEffect *effects,
+			      CompOption::Vector *effectOptions,
+			      unsigned int firstEffectOptionIndex) :
+	ExtensionPluginInfo (name, nEffects, effects, effectOptions,
+			     firstEffectOptionIndex) {}
+    ~ExtensionPluginAnimJC () {}
+
+    const CompOutput *output () { return mOutput; }
+
+private:
+    const CompOutput *mOutput;
+};
+
+class AnimJCScreen :
+    public PluginClassHandler<AnimJCScreen, CompScreen>,
+    public AnimationjcOptions
+{
+public:
+    AnimJCScreen (CompScreen *);
+    ~AnimJCScreen ();
+
+    int getIntenseTimeStep ();
+
+    void initAnimationList ();
+
+private:
+    PrivateAnimJCScreen *priv;
+};
+
+class PrivateAnimJCScreen
+{
+    friend class AnimJCScreen;
+
+public:
+    PrivateAnimJCScreen (CompScreen *);
+    ~PrivateAnimJCScreen ();
+
+protected:
+    CompOutput &mOutput;
+};
+
+class AnimJCWindow :
+    public PluginClassHandler<AnimJCWindow, CompWindow>
+{
+public:
+    AnimJCWindow (CompWindow *);
+    ~AnimJCWindow ();
+
+protected:
+    CompWindow *mWindow;    ///< Window being animated.
+    AnimWindow *aWindow;
+};
+
+/*** BLACK HOLE **************************************************************/
+
+class BlackHoleAnim :
+    public GridTransformAnim
+{
+public:
+    BlackHoleAnim (CompWindow *w,
+                   WindowEvent curWindowEvent,
+                   float duration,
+                   const AnimEffect info,
+                   const CompRect &icon);
+
+    float getBlackHoleProgress () { return progressLinear (); }
+
+    void initGrid ();
+    inline bool using3D () { return false; }
+    void step ();
+};
+
+/*** RAINDROP ****************************************************************/
+
+class RaindropAnim :
+    public GridTransformAnim
+{
+public:
+    RaindropAnim (CompWindow *w,
+                  WindowEvent curWindowEvent,
+                  float duration,
+                  const AnimEffect info,
+                  const CompRect &icon);
+
+    void initGrid ();
+
+    inline bool using3D () { return true; }
+
+    void step ();
+};
+
+/*** POPCORN *****************************************************************/
+
+class PopcornSingleAnim :
+    public TransformAnim
+{
+public:
+    PopcornSingleAnim (CompWindow *w,
+                       WindowEvent curWindowEvent,
+                       float duration,
+                       const AnimEffect info,
+                       const CompRect &icon) :
+	    Animation::Animation
+		    (w, curWindowEvent, duration, info, icon),
+	    TransformAnim::TransformAnim
+		    (w, curWindowEvent, duration, info, icon)
+    {
+    }
+
+    float layerProgress (int);
+
+    void applyTransform ();
+
+    void updateAttrib (GLWindowPaintAttrib &);
+
+    void updateBB (CompOutput &output);
+    bool updateBBUsed () { return true; }
+};
+
+class PopcornAnim :
+    public MultiAnim <PopcornSingleAnim, 6>
+{
+public:
+    PopcornAnim (CompWindow *w,
+                 WindowEvent curWindowEvent,
+                 float duration,
+                 const AnimEffect info,
+                 const CompRect &icon) :
+	    MultiAnim <PopcornSingleAnim, 6>::MultiAnim
+		    (w, curWindowEvent, duration, info, icon)
+    {
+    }
+};
+
+/*** GHOST *******************************************************************/
+
+class GhostAnim :
+    public GridTransformAnim
+{
+public:
+    GhostAnim (CompWindow *w,
+               WindowEvent curWindowEvent,
+               float duration,
+               const AnimEffect info,
+               const CompRect &icon);
+
+    void initGrid ();
+
+    inline bool using3D () { return true; }
+
+    void step ();
+
+    void updateAttrib (GLWindowPaintAttrib &);
+};
+
+/*** FLICKER *****************************************************************/
+
+class FlickerSingleAnim :
+    public GridTransformAnim
+{
+public:
+    FlickerSingleAnim (CompWindow *w,
+                       WindowEvent curWindowEvent,
+                       float duration,
+                       const AnimEffect info,
+                       const CompRect &icon) :
+	    Animation::Animation
+		    (w, curWindowEvent, duration, info, icon),
+	    TransformAnim::TransformAnim
+		    (w, curWindowEvent, duration, info, icon),
+	    GridTransformAnim::GridTransformAnim
+		    (w, curWindowEvent, duration, info, icon)
+    {
+    }
+
+    void updateAttrib (GLWindowPaintAttrib &);
+
+    void initGrid ();
+
+    void step ();
+
+    bool updateBBUsed () { return true; }
+    void updateBB (CompOutput &output) { TransformAnim::updateBB (output); }
+};
+
+class FlickerAnim :
+    public MultiAnim <FlickerSingleAnim, 5>
+{
+public:
+    FlickerAnim (CompWindow *w,
+                 WindowEvent curWindowEvent,
+                 float duration,
+                 const AnimEffect info,
+                 const CompRect &icon) :
+	    MultiAnim <FlickerSingleAnim, 5>::MultiAnim
+		    (w, curWindowEvent, duration, info, icon)
+    {
+    }
+};
diff -Npur compiz-0.9.13.0.orig/plugins/animationjc/src/raindrop.cpp compiz-0.9.13.0/plugins/animationjc/src/raindrop.cpp
--- compiz-0.9.13.0.orig/plugins/animationjc/src/raindrop.cpp	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/animationjc/src/raindrop.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,85 @@
+#include "private.h"
+
+#include <algorithm>
+
+RaindropAnim::RaindropAnim (CompWindow *w,
+			    WindowEvent curWindowEvent,
+			    float duration,
+			    const AnimEffect info,
+			    const CompRect &icon) :
+    Animation::Animation (w, curWindowEvent, duration, info, icon),
+    TransformAnim::TransformAnim (w, curWindowEvent, duration, info, icon),
+    GridTransformAnim::GridTransformAnim (w, curWindowEvent, duration, info,
+                                          icon)
+{
+}
+
+void
+RaindropAnim::initGrid ()
+{
+    mGridWidth = 20;
+    mGridHeight = 20;
+}
+
+void
+RaindropAnim::step ()
+{
+    float t = 1. - progressLinear ();
+    if (mCurWindowEvent == WindowEventClose)
+	t = 1. - t;
+
+    CompRect winRect (mAWindow->savedRectsValid () ?
+                      mAWindow->saveWinRect () :
+                      mWindow->geometry ());
+    CompRect outRect (mAWindow->savedRectsValid () ?
+                      mAWindow->savedOutRect () :
+                      mWindow->outputRect ());
+    CompWindowExtents outExtents (mAWindow->savedRectsValid () ?
+			          mAWindow->savedOutExtents () :
+			          mWindow->output ());
+
+    int wx = winRect.x ();
+    int wy = winRect.y ();
+
+    int owidth = outRect.width ();
+    int oheight = outRect.height ();
+
+    AnimJCScreen *ajs = AnimJCScreen::get (screen);
+
+    float waveLength = ajs->optionGetRaindropWavelength ();
+    int numWaves = ajs->optionGetRaindropNumWaves ();
+    float waveAmp = (pow ((float)oheight / ::screen->height (), 0.4) * 0.08) *
+	    ajs->optionGetRaindropAmplitude ();
+    float wavePosition = -waveLength * numWaves +
+	    (1. + waveLength * numWaves) * t;
+
+    GridModel::GridObject *object = mModel->objects ();
+    unsigned int n = mModel->numObjects ();
+    for (unsigned int i = 0; i < n; i++, object++)
+    {
+	Point3d &objPos = object->position ();
+
+        float origx = wx + mModel->scale ().x () *
+		(owidth * object->gridPosition ().x () -
+		outExtents.left);
+        objPos.setX (origx);
+
+	float origy = wy + mModel->scale ().y () *
+		(oheight * object->gridPosition ().y () -
+		outExtents.top);
+        objPos.setY (origy);
+
+	// find distance to center in grid terms
+	float gridDistance = sqrt (pow (object->gridPosition ().x ()-0.5, 2) +
+			           pow (object->gridPosition ().y ()-0.5, 2)) *
+			     sqrt (2);
+
+	float distFromWave = gridDistance - wavePosition;
+	if (distFromWave < waveLength*numWaves && distFromWave > 0)
+	    objPos.setZ (waveAmp *
+		    sin (3.14159265 * distFromWave / waveLength / numWaves) *
+		    pow (sin (3.14159265 * distFromWave / waveLength), 2));
+	else
+	    objPos.setZ (0);
+    }
+}
diff -Npur compiz-0.9.13.0.orig/plugins/animationplus/animationplus.xml.in compiz-0.9.13.0/plugins/animationplus/animationplus.xml.in
--- compiz-0.9.13.0.orig/plugins/animationplus/animationplus.xml.in	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/animationplus/animationplus.xml.in	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,185 @@
+<compiz>
+  <!-- animationplus metadata -->
+  <plugin name="animationplus" useBcop="true">
+    <_short>Animations Plus</_short>
+    <_long>More window animations</_long>
+    <category>Effects</category>
+    <deps>
+      <requirement>
+	<plugin>animation</plugin>
+	<plugin>animationaddon</plugin>
+      </requirement>
+      <relation type="after">
+	<plugin>animationaddon</plugin>
+	<plugin>opengl</plugin>
+	<plugin>composite</plugin>
+      </relation>
+    </deps>
+
+    <options>
+
+      <group>
+	<_short>Effect Settings</_short>
+
+        <subgroup>
+          <_short>Helix</_short>
+          <option name="helix_num_twists" type="int">
+            <_short>Helix Number of Twists</_short>
+            <_long>Number of twists to do in the animation</_long>
+            <default>2</default>
+            <min>1</min>
+            <max>10</max>
+          </option>
+          <option name="helix_gridy" type="int">
+            <_short>Helix Gridsize Y</_short>
+            <_long>Number of blocks in the animation</_long>
+            <default>90</default>
+            <min>5</min>
+            <max>300</max>
+          </option>
+          <option name="helix_thickness" type="float">
+            <_short>Helix Thickness</_short>
+            <_long>Thickness of blocks in the animation</_long>
+            <default>0</default>
+            <min>0</min>
+            <max>50</max>
+          </option>
+          <option name="helix_spin_direction" type="int">
+            <_short>Spin Direction</_short>
+            <_long>Direction the strips spin.</_long>
+            <default>1</default>
+            <min>0</min>
+            <max>1</max>
+            <desc>
+              <value>0</value>
+              <_name>Counter-Clockwise</_name>
+            </desc>
+            <desc>
+              <value>1</value>
+              <_name>Clockwise</_name>
+            </desc>
+          </option>
+          <option name="helix_direction" type="bool">
+            <_short>Vertical Helix</_short>
+            <_long>Whether Helix should rotate with its axis up/down or in/out of the screen</_long>
+            <default>false</default>
+          </option>
+        </subgroup>
+
+
+	<subgroup>
+	  <_short>Blinds</_short>
+	  <option name="blinds_num_halftwists" type="int">
+	    <_short>Blinds Number of Half Twists</_short>
+	    <_long>Number of half twists to do in the animation</_long>
+	    <default>2</default>
+	    <min>1</min>
+	    <max>10</max>
+	  </option>
+	  <option name="blinds_gridx" type="int">
+	    <_short>Helix Gridsize Y</_short>
+	    <_long>Number of blocks in the animation</_long>
+	    <default>20</default>
+	    <min>1</min>
+	    <max>100</max>
+	  </option>
+	  <option name="blinds_thickness" type="float">
+	    <_short>Blinds Thickness</_short>
+	    <_long>Thickness of blocks in the animation</_long>
+	    <default>0</default>
+	    <min>0</min>
+	    <max>50</max>
+	  </option>
+	</subgroup>
+
+	<subgroup>
+	  <_short>Shatter</_short>
+	  <option name="shatter_num_spokes" type="int">
+	    <_short>Shatter number of spokes</_short>
+	    <_long>Number of spokes (divided by 4) in the animation</_long>
+	    <default>2</default>
+	    <min>1</min>
+	    <max>100</max>
+	  </option>
+	  <option name="shatter_num_tiers" type="int">
+	    <_short>Shatter Number of Tiers</_short>
+	    <_long>Number of concentric circles in the animation</_long>
+	    <default>2</default>
+	    <min>1</min>
+	    <max>100</max>
+	  </option>
+	</subgroup>
+
+	<subgroup>
+	  <_short>Bonanza</_short>
+	  <option name="bonanza_particles" type="int">
+	    <_short>Number Of Fire Particles</_short>
+	    <_long>Number of fire particles.</_long>
+	    <default>1000</default>
+	    <min>100</min>
+	    <max>10000</max>
+	  </option>
+	  <option name="bonanza_size" type="float">
+	    <_short>Fire Particle Size</_short>
+	    <_long>Fire particle size.</_long>
+	    <default>5</default>
+	    <min>0.1</min>
+	    <max>20</max>
+	    <precision>0.1</precision>
+	  </option>
+	  <option name="bonanza_life" type="float">
+	    <_short>Fire Particle Life</_short>
+	    <_long>Fire particle life.</_long>
+	    <default>0.7</default>
+	    <min>0.1</min>
+	    <max>1</max>
+	    <precision>0.1</precision>
+	  </option>
+	  <option name="bonanza_color" type="color">
+	    <_short>Fire Particle Color</_short>
+	    <_long>Fire particle color.</_long>
+	    <default>
+	      <red>0xffff</red>
+	      <green>0x3333</green>
+	      <blue>0x0555</blue>
+	      <alpha>0xffff</alpha>
+	    </default>
+	  </option>
+	  <option name="bonanza_mystical" type="bool">
+	    <_short>Randomly Colored Fire</_short>
+	    <_long>Have random colors for the fire effect, also known as Mystical Fire.</_long>
+	    <default>false</default>
+	  </option>
+	</subgroup>
+
+      </group>
+
+    </options>
+
+    <extension base_plugin="animation">
+      <base_option>open_effects</base_option>
+      <base_option>open_random_effects</base_option>
+      <base_option>close_effects</base_option>
+      <base_option>close_random_effects</base_option>
+      <base_option>minimize_effects</base_option>
+      <base_option>minimize_random_effects</base_option>
+      <restriction>
+	<value>animationplus:Blinds</value>
+	<_name>Blinds</_name>
+      </restriction>
+      <restriction>
+	<value>animationplus:Helix</value>
+	<_name>Helix</_name>
+      </restriction>
+      <restriction>
+	<value>animationplus:Bonanza</value>
+	<_name>Bonanza</_name>
+      </restriction>
+      <restriction>
+	<value>animationplus:Shatter</value>
+	<_name>Shatter</_name>
+      </restriction>
+    </extension>
+
+  </plugin>
+</compiz>
diff -Npur compiz-0.9.13.0.orig/plugins/animationplus/CMakeLists.txt compiz-0.9.13.0/plugins/animationplus/CMakeLists.txt
--- compiz-0.9.13.0.orig/plugins/animationplus/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/animationplus/CMakeLists.txt	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,4 @@
+find_package (Compiz REQUIRED)
+include (CompizPlugin)
+
+compiz_plugin (animationplus PLUGINDEPS animation animationaddon composite opengl)
diff -Npur compiz-0.9.13.0.orig/plugins/animationplus/src/animationplus.cpp compiz-0.9.13.0/plugins/animationplus/src/animationplus.cpp
--- compiz-0.9.13.0.orig/plugins/animationplus/src/animationplus.cpp	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/animationplus/src/animationplus.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,158 @@
+/**
+ * Example Animation extension plugin for compiz
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ **/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <limits.h>
+#include "private.h"
+
+COMPIZ_PLUGIN_20090315 (animationplus, AnimPlusPluginVTable);
+
+AnimEffect animEffects[NUM_EFFECTS];
+
+ExtensionPluginAnimPlus animPlusExtPluginInfo (CompString ("animationplus"),
+						 NUM_EFFECTS, animEffects, NULL,
+                                                 NUM_NONEFFECT_OPTIONS);
+
+ExtensionPluginInfo *
+BasePlusAnim::getExtensionPluginInfo ()
+{
+    return &animPlusExtPluginInfo;
+}
+
+BasePlusAnim::BasePlusAnim (CompWindow *w,
+			    WindowEvent curWindowEvent,
+			    float	duration,
+			    const AnimEffect info,
+			    const CompRect   &icon) :
+    Animation::Animation (w, curWindowEvent, duration, info, icon),
+    mCScreen (CompositeScreen::get (::screen)),
+    mGScreen (GLScreen::get (::screen))
+{
+}
+
+/*
+// For effects with custom polygon step functions:
+AnimExtEffectProperties fxAirplaneExtraProp = {
+    .animStepPolygonFunc = fxAirplaneLinearAnimStepPolygon};
+*/
+
+AnimEffect AnimEffectBlinds;
+AnimEffect AnimEffectHelix;
+AnimEffect AnimEffectShatter;
+AnimEffect AnimEffectBonanza;
+
+void
+AnimPlusScreen::initAnimationList ()
+{
+    int i = 0;
+
+    AnimEffectUsedFor usedFor = AnimEffectUsedFor::all ()
+				.exclude (AnimEventShade)
+				.exclude (AnimEventFocus);
+
+    animEffects[i++] = AnimEffectBlinds = 
+	new AnimEffectInfo ("animationplus:Blinds",
+			     usedFor,
+			     &createAnimation <BlindsAnim>);
+
+    /* Currently broken */
+    animEffects[i++] = AnimEffectBonanza =
+	new AnimEffectInfo ("animationplus:Bonanza",
+			    usedFor,
+			    &createAnimation <BonanzaAnim>);
+
+    animEffects[i++] = AnimEffectHelix =
+	new AnimEffectInfo ("animationplus:Helix",
+			    usedFor,
+			    &createAnimation <HelixAnim>);
+
+    animEffects[i++] = AnimEffectShatter =
+	new AnimEffectInfo ("animationplus:Shatter",
+			    usedFor,
+			    &createAnimation <ShatterAnim>);
+
+    animPlusExtPluginInfo.effectOptions = &getOptions ();
+
+    AnimScreen *as = AnimScreen::get (::screen);
+
+    as->addExtension (&animPlusExtPluginInfo);
+}
+
+AnimPlusScreen::AnimPlusScreen (CompScreen *s) :
+    //cScreen (CompositeScreen::get (s)),
+    //gScreen (GLScreen::get (s)),
+    //aScreen (as),
+    PluginClassHandler <AnimPlusScreen, CompScreen> (s),
+    mOutput (s->fullscreenOutput ())
+{
+    initAnimationList ();
+}
+
+AnimPlusScreen::~AnimPlusScreen ()
+{
+    AnimScreen *as = AnimScreen::get (::screen);
+
+    as->removeExtension (&animPlusExtPluginInfo);
+
+    for (int i = 0; i < NUM_EFFECTS; i++)
+    {
+	delete animEffects[i];
+	animEffects[i] = NULL;
+    }
+}
+
+AnimPlusWindow::AnimPlusWindow (CompWindow *w) :
+    PluginClassHandler<AnimPlusWindow, CompWindow> (w),
+    mWindow (w),
+    aWindow (AnimWindow::get (w))
+{
+}
+
+AnimPlusWindow::~AnimPlusWindow ()
+{
+    Animation *curAnim = aWindow->curAnimation ();
+
+    if (!curAnim)
+	return;
+
+    // We need to interrupt and clean up the animation currently being played
+    // by animationsim for this window (if any)
+    if (curAnim->remainingTime () > 0 &&
+	curAnim->getExtensionPluginInfo ()->name ==
+	    CompString ("animationplus"))
+    {
+	aWindow->postAnimationCleanUp ();
+    }
+}
+
+bool
+AnimPlusPluginVTable::init ()
+{
+    if (!CompPlugin::checkPluginABI ("core", CORE_ABIVERSION) ||
+        !CompPlugin::checkPluginABI ("composite", COMPIZ_COMPOSITE_ABI) ||
+        !CompPlugin::checkPluginABI ("opengl", COMPIZ_OPENGL_ABI) ||
+        !CompPlugin::checkPluginABI ("animation", ANIMATION_ABI) ||
+        !CompPlugin::checkPluginABI ("animationaddon", ANIMATIONADDON_ABI))
+	 return false;
+
+    return true;
+}
diff -Npur compiz-0.9.13.0.orig/plugins/animationplus/src/animation_tex.h compiz-0.9.13.0/plugins/animationplus/src/animation_tex.h
--- compiz-0.9.13.0.orig/plugins/animationplus/src/animation_tex.h	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/animationplus/src/animation_tex.h	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,222 @@
+/**
+ *
+ * Particle texture for Beryl benchmark plugin
+ *
+ * Copyright : (C) 2006 by Dennis Kasprzyk
+ * E-mail    : onestone@beryl-project.org
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ **/
+
+static const unsigned char fireTex[4097] = {
+    "\0\0\0\0\377\377\377\3\377\377\377\2\377\377\377\5\377\377\377\7\377\377"
+    "\377\6\377\377\377\6\377\377\377\12\377\377\377\13\377\377\377\11\377\377"
+    "\377\12\377\377\377\12\377\377\377\14\377\377\377\14\377\377\377\14\377\377"
+    "\377\16\377\377\377\15\377\377\377\14\377\377\377\12\377\377\377\13\377\377"
+    "\377\13\377\377\377\11\377\377\377\12\377\377\377\12\377\377\377\10\377\377"
+    "\377\7\377\377\377\6\377\377\377\6\377\377\377\5\377\377\377\2\0\0\0\0\0"
+    "\0\0\0\377\377\377\4\377\377\377\3\377\377\377\4\377\377\377\7\377\377\377"
+    "\6\377\377\377\10\377\377\377\11\377\377\377\11\377\377\377\14\377\377\377"
+    "\14\377\377\377\15\377\377\377\16\377\377\377\20\377\377\377\21\377\377\377"
+    "\20\377\377\377\22\377\377\377\20\377\377\377\21\377\377\377\17\377\377\377"
+    "\20\377\377\377\17\377\377\377\13\377\377\377\13\377\377\377\13\377\377\377"
+    "\14\377\377\377\11\377\377\377\6\377\377\377\6\377\377\377\6\377\377\377"
+    "\4\377\377\377\1\0\0\0\0\377\377\377\5\377\377\377\4\377\377\377\6\377\377"
+    "\377\6\377\377\377\12\377\377\377\12\377\377\377\11\377\377\377\14\377\377"
+    "\377\15\377\377\377\20\377\377\377\20\377\377\377\24\377\377\377\24\377\377"
+    "\377\23\377\377\377\23\377\377\377\26\377\377\377\25\377\377\377\23\377\377"
+    "\377\21\377\377\377\24\377\377\377\22\377\377\377\17\377\377\377\17\377\377"
+    "\377\15\377\377\377\15\377\377\377\11\377\377\377\11\377\377\377\7\377\377"
+    "\377\7\377\377\377\6\377\377\377\3\377\377\377\3\377\377\377\6\377\377\377"
+    "\6\377\377\377\6\377\377\377\12\377\377\377\13\377\377\377\13\377\377\377"
+    "\13\377\377\377\17\377\377\377\22\377\377\377\24\377\377\377\22\377\377\377"
+    "\30\377\377\377\30\377\377\377\31\377\377\377\31\377\377\377\33\377\377\377"
+    "\31\377\377\377\30\377\377\377\30\377\377\377\30\377\377\377\25\377\377\377"
+    "\25\377\377\377\23\377\377\377\22\377\377\377\17\377\377\377\13\377\377\377"
+    "\12\377\377\377\11\377\377\377\7\377\377\377\6\377\377\377\5\377\377\377"
+    "\4\377\377\377\7\377\377\377\6\377\377\377\12\377\377\377\11\377\377\377"
+    "\14\377\377\377\15\377\377\377\20\377\377\377\22\377\377\377\25\377\377\377"
+    "\30\377\377\377\32\377\377\377\35\377\377\377\34\377\377\377\34\377\377\377"
+    "\36\377\377\377\40\377\377\377\36\377\377\377\34\377\377\377\34\377\377\377"
+    "\34\377\377\377\32\377\377\377\31\377\377\377\26\377\377\377\25\377\377\377"
+    "\22\377\377\377\16\377\377\377\12\377\377\377\12\377\377\377\12\377\377\377"
+    "\10\377\377\377\6\377\377\377\4\377\377\377\10\377\377\377\11\377\377\377"
+    "\12\377\377\377\13\377\377\377\16\377\377\377\21\377\377\377\22\377\377\377"
+    "\25\377\377\377\30\377\377\377\34\377\377\377\37\377\377\377!\377\377\377"
+    "\"\377\377\377#\377\377\377#\377\377\377&\377\377\377&\377\377\377$\377\377"
+    "\377#\377\377\377\40\377\377\377!\377\377\377\35\377\377\377\34\377\377\377"
+    "\25\377\377\377\24\377\377\377\21\377\377\377\15\377\377\377\14\377\377\377"
+    "\14\377\377\377\12\377\377\377\6\377\377\377\6\377\377\377\10\377\377\377"
+    "\12\377\377\377\12\377\377\377\16\377\377\377\22\377\377\377\24\377\377\377"
+    "\26\377\377\377\30\377\377\377\34\377\377\377\37\377\377\377#\377\377\377"
+    "&\377\377\377,\377\377\377+\377\377\377,\377\377\377-\377\377\377-\377\377"
+    "\377,\377\377\377+\377\377\377&\377\377\377)\377\377\377$\377\377\377\34"
+    "\377\377\377\34\377\377\377\27\377\377\377\24\377\377\377\23\377\377\377"
+    "\17\377\377\377\15\377\377\377\12\377\377\377\7\377\377\377\6\377\377\377"
+    "\12\377\377\377\12\377\377\377\16\377\377\377\21\377\377\377\22\377\377\377"
+    "\27\377\377\377\31\377\377\377\36\377\377\377!\377\377\377%\377\377\377("
+    "\377\377\3771\377\377\3772\377\377\3775\377\377\377;\377\377\377<\377\377"
+    "\3779\377\377\3778\377\377\3773\377\377\3771\377\377\377-\377\377\377'\377"
+    "\377\377\"\377\377\377\34\377\377\377\36\377\377\377\32\377\377\377\25\377"
+    "\377\377\21\377\377\377\15\377\377\377\11\377\377\377\12\377\377\377\7\377"
+    "\377\377\13\377\377\377\14\377\377\377\17\377\377\377\21\377\377\377\31\377"
+    "\377\377\31\377\377\377\35\377\377\377!\377\377\377'\377\377\377+\377\377"
+    "\3771\377\377\377=\377\377\377E\377\377\377H\377\377\377M\377\377\377M\377"
+    "\377\377J\377\377\377I\377\377\377A\377\377\377A\377\377\3778\377\377\377"
+    ",\377\377\377%\377\377\377$\377\377\377\"\377\377\377\34\377\377\377\24\377"
+    "\377\377\22\377\377\377\17\377\377\377\13\377\377\377\12\377\377\377\11\377"
+    "\377\377\13\377\377\377\14\377\377\377\20\377\377\377\23\377\377\377\27\377"
+    "\377\377\35\377\377\377$\377\377\377(\377\377\377.\377\377\3776\377\377\377"
+    "=\377\377\377H\377\377\377W\377\377\377Y\377\377\377]\377\377\377a\377\377"
+    "\377\\\377\377\377\\\377\377\377U\377\377\377O\377\377\377?\377\377\3774"
+    "\377\377\377-\377\377\377+\377\377\377\40\377\377\377\32\377\377\377\27\377"
+    "\377\377\23\377\377\377\22\377\377\377\15\377\377\377\11\377\377\377\13\377"
+    "\377\377\12\377\377\377\15\377\377\377\21\377\377\377\25\377\377\377\30\377"
+    "\377\377\37\377\377\377$\377\377\377.\377\377\3779\377\377\377?\377\377\377"
+    "N\377\377\377X\377\377\377h\377\377\377r\377\377\377w\377\377\377|\377\377"
+    "\377x\377\377\377p\377\377\377k\377\377\377\\\377\377\377J\377\377\377F\377"
+    "\377\3779\377\377\377*\377\377\377$\377\377\377\36\377\377\377\30\377\377"
+    "\377\25\377\377\377\24\377\377\377\20\377\377\377\14\377\377\377\12\377\377"
+    "\377\15\377\377\377\17\377\377\377\22\377\377\377\27\377\377\377\34\377\377"
+    "\377\40\377\377\377%\377\377\377.\377\377\377<\377\377\377M\377\377\377["
+    "\377\377\377l\377\377\377~\377\377\377\227\377\377\377\230\377\377\377\234"
+    "\377\377\377\233\377\377\377\226\377\377\377\205\377\377\377i\377\377\377"
+    "b\377\377\377P\377\377\3779\377\377\377-\377\377\377(\377\377\377!\377\377"
+    "\377\35\377\377\377\32\377\377\377\25\377\377\377\21\377\377\377\13\377\377"
+    "\377\12\377\377\377\15\377\377\377\21\377\377\377\23\377\377\377\31\377\377"
+    "\377\37\377\377\377!\377\377\377(\377\377\3774\377\377\377@\377\377\377Q"
+    "\377\377\377g\377\377\377\200\377\377\377\231\377\377\377\254\377\377\377"
+    "\275\377\377\377\310\377\377\377\304\377\377\377\264\377\377\377\227\377"
+    "\377\377\212\377\377\377f\377\377\377Q\377\377\377B\377\377\377:\377\377"
+    "\377/\377\377\377&\377\377\377\36\377\377\377\32\377\377\377\26\377\377\377"
+    "\21\377\377\377\14\377\377\377\12\377\377\377\17\377\377\377\22\377\377\377"
+    "\24\377\377\377\31\377\377\377\40\377\377\377&\377\377\377-\377\377\377:"
+    "\377\377\377H\377\377\377X\377\377\377k\377\377\377\220\377\377\377\252\377"
+    "\377\377\324\377\377\377\363\377\377\377\370\377\377\377\366\377\377\377"
+    "\335\377\377\377\263\377\377\377\221\377\377\377w\377\377\377b\377\377\377"
+    "P\377\377\377>\377\377\3770\377\377\377&\377\377\377\37\377\377\377\32\377"
+    "\377\377\26\377\377\377\23\377\377\377\15\377\377\377\11\377\377\377\16\377"
+    "\377\377\21\377\377\377\27\377\377\377\33\377\377\377\"\377\377\377(\377"
+    "\377\377/\377\377\377<\377\377\377N\377\377\377b\377\377\377z\377\377\377"
+    "\231\377\377\377\275\377\377\377\361\377\377\377\375\377\377\377\376\377"
+    "\377\377\376\377\377\377\370\377\377\377\316\377\377\377\240\377\377\377"
+    "\205\377\377\377b\377\377\377L\377\377\377<\377\377\377.\377\377\377&\377"
+    "\377\377\40\377\377\377\33\377\377\377\26\377\377\377\22\377\377\377\15\377"
+    "\377\377\12\377\377\377\16\377\377\377\22\377\377\377\24\377\377\377\32\377"
+    "\377\377\40\377\377\377$\377\377\377,\377\377\377:\377\377\377L\377\377\377"
+    "`\377\377\377|\377\377\377\231\377\377\377\310\377\377\377\372\377\377\377"
+    "\375\377\377\377\376\377\377\377\376\377\377\377\375\377\377\377\332\377"
+    "\377\377\241\377\377\377\207\377\377\377f\377\377\377R\377\377\377@\377\377"
+    "\3773\377\377\377+\377\377\377\"\377\377\377\35\377\377\377\30\377\377\377"
+    "\24\377\377\377\17\377\377\377\14\377\377\377\16\377\377\377\22\377\377\377"
+    "\25\377\377\377\30\377\377\377\40\377\377\377$\377\377\377,\377\377\377;"
+    "\377\377\377N\377\377\377e\377\377\377\206\377\377\377\246\377\377\377\327"
+    "\377\377\377\374\377\377\377\375\377\377\377\376\377\377\377\376\377\377"
+    "\377\374\377\377\377\331\377\377\377\243\377\377\377\210\377\377\377b\377"
+    "\377\377O\377\377\377>\377\377\377.\377\377\377&\377\377\377\40\377\377\377"
+    "\33\377\377\377\27\377\377\377\22\377\377\377\15\377\377\377\12\377\377\377"
+    "\16\377\377\377\22\377\377\377\23\377\377\377\32\377\377\377\40\377\377\377"
+    "'\377\377\3770\377\377\377?\377\377\377U\377\377\377h\377\377\377\200\377"
+    "\377\377\237\377\377\377\270\377\377\377\344\377\377\377\372\377\377\377"
+    "\375\377\377\377\376\377\377\377\354\377\377\377\275\377\377\377\227\377"
+    "\377\377\200\377\377\377e\377\377\377Q\377\377\377>\377\377\377.\377\377"
+    "\377%\377\377\377\40\377\377\377\33\377\377\377\26\377\377\377\22\377\377"
+    "\377\15\377\377\377\11\377\377\377\17\377\377\377\22\377\377\377\25\377\377"
+    "\377\31\377\377\377\"\377\377\377*\377\377\3773\377\377\377=\377\377\377"
+    "J\377\377\377^\377\377\377o\377\377\377\211\377\377\377\235\377\377\377\271"
+    "\377\377\377\327\377\377\377\342\377\377\377\335\377\377\377\302\377\377"
+    "\377\240\377\377\377\216\377\377\377k\377\377\377X\377\377\377C\377\377\377"
+    "9\377\377\377/\377\377\377&\377\377\377\"\377\377\377\33\377\377\377\26\377"
+    "\377\377\22\377\377\377\14\377\377\377\12\377\377\377\15\377\377\377\22\377"
+    "\377\377\31\377\377\377\35\377\377\377\37\377\377\377$\377\377\377,\377\377"
+    "\3777\377\377\377A\377\377\377Q\377\377\377[\377\377\377p\377\377\377\212"
+    "\377\377\377\231\377\377\377\242\377\377\377\253\377\377\377\251\377\377"
+    "\377\236\377\377\377\215\377\377\377u\377\377\377b\377\377\377O\377\377\377"
+    "<\377\377\3771\377\377\377)\377\377\377\"\377\377\377\34\377\377\377\32\377"
+    "\377\377\27\377\377\377\21\377\377\377\16\377\377\377\12\377\377\377\17\377"
+    "\377\377\21\377\377\377\20\377\377\377\27\377\377\377\37\377\377\377$\377"
+    "\377\377&\377\377\377,\377\377\3778\377\377\377B\377\377\377R\377\377\377"
+    "_\377\377\377k\377\377\377~\377\377\377\207\377\377\377\220\377\377\377\220"
+    "\377\377\377\203\377\377\377q\377\377\377_\377\377\377V\377\377\377F\377"
+    "\377\3777\377\377\377,\377\377\377%\377\377\377!\377\377\377\31\377\377\377"
+    "\25\377\377\377\22\377\377\377\17\377\377\377\14\377\377\377\11\377\377\377"
+    "\12\377\377\377\16\377\377\377\22\377\377\377\27\377\377\377\33\377\377\377"
+    "\35\377\377\377\"\377\377\377(\377\377\377/\377\377\3779\377\377\377E\377"
+    "\377\377L\377\377\377^\377\377\377d\377\377\377e\377\377\377k\377\377\377"
+    "l\377\377\377d\377\377\377a\377\377\377O\377\377\377C\377\377\377=\377\377"
+    "\3770\377\377\377)\377\377\377$\377\377\377\35\377\377\377\30\377\377\377"
+    "\25\377\377\377\22\377\377\377\16\377\377\377\12\377\377\377\13\377\377\377"
+    "\13\377\377\377\15\377\377\377\20\377\377\377\21\377\377\377\31\377\377\377"
+    "\33\377\377\377\35\377\377\377$\377\377\377)\377\377\3771\377\377\3776\377"
+    "\377\377@\377\377\377J\377\377\377N\377\377\377P\377\377\377S\377\377\377"
+    "X\377\377\377P\377\377\377J\377\377\377E\377\377\3777\377\377\377,\377\377"
+    "\377+\377\377\377%\377\377\377\40\377\377\377\32\377\377\377\26\377\377\377"
+    "\21\377\377\377\21\377\377\377\14\377\377\377\11\377\377\377\12\377\377\377"
+    "\13\377\377\377\11\377\377\377\14\377\377\377\21\377\377\377\23\377\377\377"
+    "\27\377\377\377\33\377\377\377\37\377\377\377&\377\377\377(\377\377\377*"
+    "\377\377\3774\377\377\3779\377\377\377<\377\377\377=\377\377\377C\377\377"
+    "\377E\377\377\377?\377\377\3779\377\377\377:\377\377\377.\377\377\377(\377"
+    "\377\377!\377\377\377!\377\377\377\35\377\377\377\31\377\377\377\24\377\377"
+    "\377\21\377\377\377\16\377\377\377\12\377\377\377\11\377\377\377\10\377\377"
+    "\377\10\377\377\377\11\377\377\377\13\377\377\377\16\377\377\377\22\377\377"
+    "\377\25\377\377\377\30\377\377\377\33\377\377\377\"\377\377\377!\377\377"
+    "\377%\377\377\377*\377\377\377-\377\377\3770\377\377\377/\377\377\3773\377"
+    "\377\3772\377\377\3774\377\377\377-\377\377\377,\377\377\377*\377\377\377"
+    "\"\377\377\377\37\377\377\377\32\377\377\377\33\377\377\377\27\377\377\377"
+    "\21\377\377\377\17\377\377\377\16\377\377\377\12\377\377\377\11\377\377\377"
+    "\6\377\377\377\10\377\377\377\12\377\377\377\11\377\377\377\15\377\377\377"
+    "\20\377\377\377\22\377\377\377\23\377\377\377\30\377\377\377\32\377\377\377"
+    "\35\377\377\377\40\377\377\377!\377\377\377%\377\377\377(\377\377\377&\377"
+    "\377\377)\377\377\377(\377\377\377+\377\377\377$\377\377\377!\377\377\377"
+    "#\377\377\377\36\377\377\377\30\377\377\377\30\377\377\377\24\377\377\377"
+    "\22\377\377\377\20\377\377\377\15\377\377\377\11\377\377\377\12\377\377\377"
+    "\6\377\377\377\6\377\377\377\7\377\377\377\7\377\377\377\11\377\377\377\12"
+    "\377\377\377\16\377\377\377\17\377\377\377\22\377\377\377\23\377\377\377"
+    "\26\377\377\377\31\377\377\377\33\377\377\377\34\377\377\377!\377\377\377"
+    "\40\377\377\377\"\377\377\377\"\377\377\377\"\377\377\377&\377\377\377\36"
+    "\377\377\377\35\377\377\377\35\377\377\377\34\377\377\377\26\377\377\377"
+    "\24\377\377\377\23\377\377\377\20\377\377\377\15\377\377\377\14\377\377\377"
+    "\13\377\377\377\7\377\377\377\5\377\377\377\6\377\377\377\7\377\377\377\6"
+    "\377\377\377\11\377\377\377\12\377\377\377\11\377\377\377\15\377\377\377"
+    "\16\377\377\377\21\377\377\377\22\377\377\377\26\377\377\377\26\377\377\377"
+    "\30\377\377\377\33\377\377\377\32\377\377\377\34\377\377\377\33\377\377\377"
+    "\32\377\377\377\37\377\377\377\31\377\377\377\31\377\377\377\27\377\377\377"
+    "\30\377\377\377\21\377\377\377\22\377\377\377\17\377\377\377\14\377\377\377"
+    "\11\377\377\377\11\377\377\377\12\377\377\377\6\377\377\377\6\377\377\377"
+    "\4\377\377\377\6\377\377\377\6\377\377\377\5\377\377\377\7\377\377\377\13"
+    "\377\377\377\11\377\377\377\12\377\377\377\16\377\377\377\21\377\377\377"
+    "\21\377\377\377\20\377\377\377\22\377\377\377\30\377\377\377\26\377\377\377"
+    "\27\377\377\377\30\377\377\377\27\377\377\377\30\377\377\377\26\377\377\377"
+    "\23\377\377\377\22\377\377\377\20\377\377\377\20\377\377\377\16\377\377\377"
+    "\14\377\377\377\11\377\377\377\11\377\377\377\10\377\377\377\6\377\377\377"
+    "\6\377\377\377\4\377\377\377\3\377\377\377\4\377\377\377\4\377\377\377\4"
+    "\377\377\377\7\377\377\377\10\377\377\377\12\377\377\377\10\377\377\377\11"
+    "\377\377\377\15\377\377\377\16\377\377\377\16\377\377\377\20\377\377\377"
+    "\23\377\377\377\21\377\377\377\23\377\377\377\22\377\377\377\22\377\377\377"
+    "\21\377\377\377\22\377\377\377\22\377\377\377\20\377\377\377\16\377\377\377"
+    "\15\377\377\377\12\377\377\377\11\377\377\377\12\377\377\377\7\377\377\377"
+    "\6\377\377\377\7\377\377\377\5\377\377\377\4\377\377\377\1\377\377\377\1"
+    "\377\377\377\3\377\377\377\3\377\377\377\6\377\377\377\7\377\377\377\6\377"
+    "\377\377\10\377\377\377\12\377\377\377\12\377\377\377\11\377\377\377\13\377"
+    "\377\377\16\377\377\377\16\377\377\377\16\377\377\377\17\377\377\377\16\377"
+    "\377\377\16\377\377\377\17\377\377\377\17\377\377\377\15\377\377\377\14\377"
+    "\377\377\12\377\377\377\11\377\377\377\12\377\377\377\12\377\377\377\7\377"
+    "\377\377\6\377\377\377\6\377\377\377\6\377\377\377\3\377\377\377\1\377\377"
+    "\377\1\0\0\0\0\0\0\0\0\377\377\377\2\377\377\377\4\377\377\377\7\377\377"
+    "\377\6\377\377\377\6\377\377\377\7\377\377\377\13\377\377\377\13\377\377"
+    "\377\10\377\377\377\11\377\377\377\11\377\377\377\11\377\377\377\15\377\377"
+    "\377\13\377\377\377\14\377\377\377\11\377\377\377\13\377\377\377\11\377\377"
+    "\377\12\377\377\377\13\377\377\377\11\377\377\377\11\377\377\377\6\377\377"
+    "\377\7\377\377\377\4\377\377\377\5\377\377\377\3\377\377\377\1\0\0\0\0\0"
+    "\0\0\0"
+};
diff -Npur compiz-0.9.13.0.orig/plugins/animationplus/src/blinds.cpp compiz-0.9.13.0/plugins/animationplus/src/blinds.cpp
--- compiz-0.9.13.0.orig/plugins/animationplus/src/blinds.cpp	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/animationplus/src/blinds.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,70 @@
+/*
+ * Animation plugin for compiz/beryl
+ *
+ * blinds.cpp
+ *
+ * Copyright : (C) 2008 Kevin DuBois
+ * E-mail    : kdub432@gmail.com
+ *
+ * Based on other animations by
+ *           : Erkin Bahceci
+ * E-mail    : erkinbah@gmail.com
+ * 
+ * Which were based on Wobbly and Minimize plugins by
+ *           : David Reveman
+ * E-mail    : davidr@novell.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *const float ExplodeAnim::kDurationFactor = 1.43;
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include "private.h"
+
+const float BlindsAnim::kDurationFactor = 1.43;
+
+
+BlindsAnim::BlindsAnim (CompWindow *w,
+			WindowEvent curWindowEvent,
+			float	    duration,
+			const AnimEffect info,
+			const CompRect   &icon) :
+    Animation::Animation (w, curWindowEvent, kDurationFactor * duration, info, icon),
+    PolygonAnim::PolygonAnim (w, curWindowEvent, kDurationFactor * duration, info, icon)
+{
+    mAllFadeDuration = 0.3f;
+    mDoDepthTest = true;
+    mDoLighting = true;
+    mCorrectPerspective = CorrectPerspectivePolygon;
+    mBackAndSidesFadeDur = 0.2f;
+}
+
+void
+BlindsAnim::init ()
+{
+    ANIMPLUS_SCREEN (screen);
+
+    tessellateIntoRectangles (as->optionGetBlindsGridx (), 1,
+			      as->optionGetBlindsThickness ());
+
+    foreach (PolygonObject *p, mPolygons)
+    {
+	//rotate around y axis
+	p->rotAxis.set (0, 1, 0);
+	p->finalRelPos.set (0, 0, 0);
+
+	int numberOfHalfTwists = as->optionGetBlindsNumHalftwists ();
+	p->finalRotAng = 180 * numberOfHalfTwists ;
+    }
+}
+
diff -Npur compiz-0.9.13.0.orig/plugins/animationplus/src/bonanza.cpp compiz-0.9.13.0/plugins/animationplus/src/bonanza.cpp
--- compiz-0.9.13.0.orig/plugins/animationplus/src/bonanza.cpp	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/animationplus/src/bonanza.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,241 @@
+/*
+ * Animation plugin for compiz/beryl
+ *
+ * bonanza.c
+ *
+ * Copyright : (C) 2008 Kevin DuBois
+ * E-mail    : kdub423@gmail.com
+ *
+ * Based on animations system by: (C) 2006 Erkin Bahceci
+ * E-mail                       : erkinbah@gmail.com
+ *
+ * Based on particle system added by : (C) 2006 Dennis Kasprzyk
+ * E-mail                            : onestone@beryl-project.org
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include "private.h"
+#include "animation_tex.h"
+
+// =====================  Effect: Burn  =========================
+
+BonanzaAnim::BonanzaAnim (CompWindow *w,
+			  WindowEvent curWindowEvent,
+			  float	    duration,
+			  const AnimEffect info,
+			  const CompRect   &icon) :
+    Animation::Animation (w, curWindowEvent, duration, info, icon),
+    ParticleAnim::ParticleAnim (w, curWindowEvent, duration, info, icon)
+{
+    ANIMPLUS_SCREEN (screen);
+
+    // Light Particles are for extras, dark particles unused?
+    initLightDarkParticles (as->optionGetBonanzaParticles (),
+			    as->optionGetBonanzaParticles () / 10,
+			    0.125,
+			    0.5);
+
+    mAnimFireDirection = 0;
+}
+
+void
+BonanzaAnim::genFire (int x,
+		      int y,
+		      int radius,
+		      float size,
+		      float time)                
+{
+    ANIMPLUS_SCREEN (screen);
+
+    ParticleSystem &ps = mParticleSystems[0];
+
+    float fireLife = as->optionGetBonanzaLife ();
+    float fireLifeNeg = 1 - fireLife;
+    float fadeExtra = 0.2f * (1.01 - fireLife);
+    float max_new = ps.particles ().size () * (time / 50) * (1.05 - fireLife);
+    float numParticles = ps.particles ().size ();
+
+    unsigned short *c =	as->optionGetBonanzaColor ();
+    float colr1 = (float)c[0] / 0xffff;
+    float colg1 = (float)c[1] / 0xffff;
+    float colb1 = (float)c[2] / 0xffff;
+    float colr2 = 1 / 1.7 * (float)c[0] / 0xffff;
+    float colg2 = 1 / 1.7 * (float)c[1] / 0xffff;
+    float colb2 = 1 / 1.7 * (float)c[2] / 0xffff;
+    float cola = (float)c[3] / 0xffff;
+    float rVal;
+
+    Particle *part = &(ps.particles ()[0]);
+
+    float deg = 0;
+    float inc = 2.0 * 3.1415 / numParticles;
+    float partw = 5.00;
+    float parth = partw * 1.5;
+    bool mysticalFire = as->optionGetBonanzaMystical ();
+
+    for (unsigned int i = 0; i < numParticles && max_new > 0; i++, part++)
+    {
+        deg += inc; 
+
+        if (part->life <= 0.0f)
+        {
+            // give gt new life
+            rVal = (float)(random() & 0xff) / 255.0;
+            part->life = 1.0f;
+            part->fade = rVal * fireLifeNeg + fadeExtra; // Random Fade Value
+
+            // set size
+            part->width = partw;
+            part->height = parth;
+            rVal = (float)(random() & 0xff) / 255.0;
+            part->w_mod = part->h_mod = size * rVal;
+
+            part->x = (float)x + (float) radius * cosf(deg);
+            part->y = (float)y + (float) radius * sinf(deg);
+
+            //clip
+            if (part->x <= 0)
+            part->x = 0;
+            if (part->x >= 2 * x)
+                part->x = 2*x;
+        
+            if (part->y <= 0)
+            part->y = 0;
+            if (part->y >= 2 * y)
+                part->y = 2*y;
+
+            part->z = 0.0;
+
+            part->xo = part->x;
+            part->yo = part->y;
+            part->zo = 0.0f;
+
+            // set speed and direction
+            rVal = (float)(random() & 0xff) / 255.0;
+            part->xi = ((rVal * 20.0) - 10.0f);
+            rVal = (float)(random() & 0xff) / 255.0;
+            part->yi = ((rVal * 20.0) - 15.0f);
+            part->zi = 0.0f;
+
+            if (mysticalFire)
+            {
+                // Random colors! (aka Mystical Fire)
+                rVal = (float)(random() & 0xff) / 255.0;
+                part->r = rVal;
+                rVal = (float)(random() & 0xff) / 255.0;
+                part->g = rVal;
+                rVal = (float)(random() & 0xff) / 255.0;
+                part->b = rVal;
+            }
+            else
+            {
+                rVal = (float)(random() & 0xff) / 255.0;
+                part->r = colr1 - rVal * colr2;
+                part->g = colg1 - rVal * colg2;
+                part->b = colb1 - rVal * colb2;
+            }
+            // set transparancy
+            part->a = cola;
+
+            // set gravity
+            part->xg = (part->x < part->xo) ? 1.0 : -1.0;
+            part->yg = -3.0f;
+            part->zg = 0.0f;
+
+            ps.activate ();
+            max_new -= 1;
+        }
+        else
+        {
+            part->xg = (part->x < part->xo) ? 1.0 : -1.0;
+        }
+
+    }
+
+}
+
+void
+BonanzaAnim::step (float time)
+{
+    float timestep = 2.0;
+    CompRect rect = mWindow->outputRect ();
+
+    mRemainingTime -= timestep;
+    if (mRemainingTime <= 0)
+	    mRemainingTime = 0;	// avoid sub-zero values
+    float new_f = 1 - (mRemainingTime) / (mTotalTime - timestep);
+
+    if (mCurWindowEvent == WindowEventOpen ||
+	mCurWindowEvent == WindowEventUnminimize ||
+	mCurWindowEvent == WindowEventUnshade)
+    {
+	new_f = 1 - new_f;
+    }
+    
+    mUseDrawRegion = true;
+    mDrawRegion = CompRegion ();
+
+
+    /* define an expanding circle as a union of rectangular X regions. */
+    float radius = 0;
+    if (mRemainingTime > 0)
+    {        
+	XPoint pts[20];
+
+        int i;
+        float two_pi = 3.14159 * 2.0;
+        int centerX = rect.centerX () + rect.x ();
+        int centerY = rect.centerY () + rect.y ();
+        float corner_dist = sqrt( powf(rect.centerX ()/2,2) + powf(rect.centerY (),2));
+        radius = new_f * corner_dist;
+        for (i = 0; i < 20; i++)
+        {
+	    pts[i].x = centerX + (int)(radius * cosf( (float) i/20.0 * two_pi ));
+	    pts[i].y = centerY + (int)(radius * sinf( (float) i/20.0 * two_pi ));
+        }
+        
+	Region pointsRegion = XPolygonRegion (&pts[0], 20, WindingRule);;
+	mDrawRegion = CompRegionRef(pointsRegion) - emptyRegion.united (rect);
+	XDestroyRegion (pointsRegion);
+    }
+    else
+    {
+    	mDrawRegion = emptyRegion;
+    }
+
+
+    mUseDrawRegion = (fabs (new_f) > 1e-5);
+
+    genFire (rect.centerX (),
+	     rect.centerY (),
+             radius,
+             WIN_W(mWindow) / 40.0,
+             time);
+
+    if (mRemainingTime <= 0 && mParticleSystems.size () && mParticleSystems.at (0).active ())
+    {
+        mRemainingTime = 0;
+    }
+
+    if (mParticleSystems.empty () || !mParticleSystems.at (0).active ())
+    {
+	mParticleSystems.clear ();
+	// Abort animation
+	compLogMessage ("animationaddon", CompLogLevelError, "Couldn't do bonanza animation\n");
+	mRemainingTime = 0;
+    }
+}
+
diff -Npur compiz-0.9.13.0.orig/plugins/animationplus/src/helix.cpp compiz-0.9.13.0/plugins/animationplus/src/helix.cpp
--- compiz-0.9.13.0.orig/plugins/animationplus/src/helix.cpp	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/animationplus/src/helix.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,93 @@
+/*
+ * Animation plugin for compiz/beryl
+ *
+ * animation.c
+ *
+ * Copyright : (C) 2008 Kevin DuBois
+ * E-mail    : kdub432@gmail.com
+ *
+ * Based on other animations by
+ *           : Erkin Bahceci
+ * E-mail    : erkinbah@gmail.com
+ * 
+ * Which were based on Wobbly and Minimize plugins by
+ *           : David Reveman
+ * E-mail    : davidr@novell.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include "private.h"
+
+const float HelixAnim::kDurationFactor = 1.43;
+
+HelixAnim::HelixAnim (CompWindow *w,
+		      WindowEvent curWindowEvent,
+		      float	    duration,
+		      const AnimEffect info,
+		      const CompRect   &icon) :
+    Animation::Animation (w, curWindowEvent, kDurationFactor * duration, info, icon),
+    PolygonAnim::PolygonAnim (w, curWindowEvent, kDurationFactor * duration, info, icon)
+{
+    mAllFadeDuration = 0.4f;
+    mBackAndSidesFadeDur = 0.2f;
+    mDoDepthTest = TRUE;
+    mDoLighting = TRUE;
+    mCorrectPerspective = CorrectPerspectivePolygon;
+}
+
+void
+HelixAnim::init ()
+{
+    ANIMPLUS_SCREEN (screen);
+
+    int gridsizeY = as->optionGetHelixGridy ();
+    int count = 0;
+
+    tessellateIntoRectangles (1, gridsizeY, as->optionGetHelixThickness ());
+
+    foreach (PolygonObject *p, mPolygons)
+    {
+        
+	//rotate around y axis normally, or the z axis if the effect is in vertical mode
+	if (as->optionGetHelixDirection ())
+	    p->rotAxis.set (0, 0, 1);
+	else
+	    p->rotAxis.set (0, 1, 0);
+
+	//only move the pieces in a 'vertical' rotation
+	if (as->optionGetHelixDirection ())
+	    p->finalRelPos.set (0,
+				-1 * ((mWindow->height () / gridsizeY) * (count - gridsizeY/2)),
+				0);
+	else
+	    p->finalRelPos.set (0,
+				0,
+				0);
+
+	//determine how long, and what direction to spin
+	int numberOfTwists = as->optionGetHelixNumTwists ();
+	int spin_dir = as->optionGetHelixSpinDirection ();
+
+	if (spin_dir)
+	    p->finalRotAng = 270 - ( 2 * numberOfTwists * count); 
+	else
+	    p->finalRotAng = ( 2 * numberOfTwists * count) - 270; 
+
+	count++;        
+       
+    }
+}
+
diff -Npur compiz-0.9.13.0.orig/plugins/animationplus/src/private.h compiz-0.9.13.0/plugins/animationplus/src/private.h
--- compiz-0.9.13.0.orig/plugins/animationplus/src/private.h	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/animationplus/src/private.h	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,196 @@
+#include <string.h>
+#include <stdlib.h>
+#include <math.h>
+#include <sys/time.h>
+
+#ifdef USE_LIBRSVG
+#include <cairo/cairo.h>
+#include <cairo/cairo-xlib.h>
+#include <librsvg/rsvg.h>
+#include <librsvg/rsvg-cairo.h>
+#endif
+
+#include <core/core.h>
+#include <opengl/opengl.h>
+#include <composite/composite.h>
+#include <animation/animation.h>
+#include <animationaddon/animationaddon.h>
+
+#include "animationplus_options.h"
+
+extern AnimEffect AnimEffectBlinds;
+extern AnimEffect AnimEffectBonanza;
+extern AnimEffect AnimEffectHelix;
+extern AnimEffect AnimEffectShatter;
+
+#define NUM_EFFECTS 4
+
+// This must have the value of the first "effect setting" above
+// in AnimEgScreenOptions
+#define NUM_NONEFFECT_OPTIONS 0
+
+#define WIN_X(w) ((w)->x () - (w)->input ().left)
+#define WIN_Y(w) ((w)->y () - (w)->input ().top)
+#define WIN_W(w) ((w)->width () + (w)->input ().left + (w)->input ().right)
+#define WIN_H(w) ((w)->height () + (w)->input ().top + (w)->input ().bottom)
+
+class ExtensionPluginAnimPlus : public ExtensionPluginInfo
+{
+    public:
+
+	ExtensionPluginAnimPlus (const CompString &name,
+				 unsigned int	  nEffects,
+				 AnimEffect	  *effects,
+				 CompOption::Vector *effectOptions,
+				 unsigned int	  firstEffectOptionIndex) :
+		ExtensionPluginInfo (name, nEffects, effects, effectOptions,
+				      firstEffectOptionIndex) {}
+	~ExtensionPluginAnimPlus () {}
+
+	const CompOutput *output () { return mOutput; }
+    private:
+
+	const CompOutput *mOutput;
+};
+
+class BasePlusAnim :
+    virtual public Animation
+{
+    public:
+
+	BasePlusAnim (CompWindow *w,
+		      WindowEvent curWindowEvent,
+		      float	 duration,
+		      const AnimEffect info,
+		      const CompRect   &icon);
+
+	~BasePlusAnim () {}
+
+    protected:
+	// Gets info about the extension plugin that implements this animation.
+	ExtensionPluginInfo* getExtensionPluginInfo ();
+
+	CompositeScreen *mCScreen;
+	GLScreen	*mGScreen;
+};
+
+class AnimPlusScreen :
+    public PluginClassHandler <AnimPlusScreen, CompScreen>,
+    public AnimationplusOptions
+{
+    public:
+
+	AnimPlusScreen (CompScreen *);
+	~AnimPlusScreen ();
+
+    protected:
+
+	void initAnimationList ();
+
+	CompOutput &mOutput;
+};
+
+class AnimPlusWindow :
+    public PluginClassHandler <AnimPlusWindow, CompWindow>
+{
+    public:
+
+	AnimPlusWindow (CompWindow *);
+	~AnimPlusWindow ();
+
+    protected:
+
+	CompWindow *mWindow;
+	AnimWindow *aWindow;
+
+};
+
+#define ANIMPLUS_SCREEN(s)					    \
+    AnimPlusScreen *as = AnimPlusScreen::get (s);
+
+#define ANIMPLUS_WINDOW(w)					    \
+    AnimPlusWindow *aw = AnimPlusWindow::get (w);
+
+// ratio of perceived length of animation compared to real duration
+// to make it appear to have the same speed with other animation effects
+
+#define EXPLODE_PERCEIVED_T 0.7f
+
+/*
+ * Function prototypes
+ *
+ */
+
+class BlindsAnim : public PolygonAnim
+{
+    public:
+
+	BlindsAnim (CompWindow *w,
+		    WindowEvent curWindowEvent,
+		    float	    duration,
+		    const	    AnimEffect info,
+		    const	    CompRect   &icon);
+
+	void init ();
+    protected:
+	static const float kDurationFactor;
+};
+
+class HelixAnim : public PolygonAnim
+{
+    public:
+	HelixAnim (CompWindow *w,
+		   WindowEvent curWindowEvent,
+		   float       duration,
+		   const       AnimEffect info,
+		   const       CompRect   &icon);
+
+	void init ();
+    protected:
+	static const float kDurationFactor;
+};
+
+class BonanzaAnim : public ParticleAnim
+{
+    public:
+	BonanzaAnim (CompWindow *w,
+		     WindowEvent curWindowEvent,
+		     float	 duration,
+		     const	 AnimEffect info,
+		     const	 CompRect   &icon);
+
+	void
+	genFire (int x,
+		 int y,
+		 int radius,
+		 float size,
+		float time);
+
+	void step (float);
+    protected:
+
+	int  mAnimFireDirection;
+	unsigned int mFirePDId;
+};
+
+class ShatterAnim : public PolygonAnim
+{
+    public:
+	ShatterAnim (CompWindow *w,
+		     WindowEvent curWindowEvent,
+		     float	    duration,
+		     const	    AnimEffect info,
+		     const	    CompRect   &icon);
+
+	void init ();
+    protected:
+	static const float kDurationFactor;
+};
+
+class AnimPlusPluginVTable :
+    public CompPlugin::VTableForScreenAndWindow <AnimPlusScreen, AnimPlusWindow>
+{
+    public:
+
+	bool init ();
+};
diff -Npur compiz-0.9.13.0.orig/plugins/animationplus/src/shatter.cpp compiz-0.9.13.0/plugins/animationplus/src/shatter.cpp
--- compiz-0.9.13.0.orig/plugins/animationplus/src/shatter.cpp	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/animationplus/src/shatter.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,75 @@
+/*
+ * Animation plugin for compiz/beryl
+ *
+ * animation.c
+ *
+ * Copyright : (C) 2008 Kevin DuBois
+ * E-mail    : kdub432@gmail.com
+ *
+ * Based on other animations by
+ *           : Erkin Bahceci
+ * E-mail    : erkinbah@gmail.com
+ * 
+ * Which were based on Wobbly and Minimize plugins by
+ *           : David Reveman
+ * E-mail    : davidr@novell.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+#include "private.h"
+
+const float ShatterAnim::kDurationFactor = 1.43;
+
+ShatterAnim::ShatterAnim (CompWindow *w,
+			  WindowEvent curWindowEvent,
+			  float	      duration,
+			  const AnimEffect info,
+			  const CompRect   &icon) :
+	Animation::Animation (w, curWindowEvent, kDurationFactor * duration, info,
+			      icon),
+	PolygonAnim::PolygonAnim (w, curWindowEvent, kDurationFactor * duration,
+				  info, icon)
+{
+    mAllFadeDuration = 0.4f;
+    mBackAndSidesFadeDur = 0.2f;
+    mDoDepthTest = true;
+    mDoLighting = true;
+    mCorrectPerspective = CorrectPerspectivePolygon;
+}
+
+void
+ShatterAnim::init ()
+{
+    ANIMPLUS_SCREEN (screen);
+    int static_polygon;
+    int screen_height = screen->outputDevs ().at (mWindow->outputDevice ()).height ();
+
+    tessellateIntoGlass (as->optionGetShatterNumSpokes (),
+			 as->optionGetShatterNumTiers (),
+			 1); //can't really see how thick it is...
+
+    foreach (PolygonObject *p, mPolygons)
+    {
+	p->rotAxis.set (0, 0, 1);
+	static_polygon = 1;
+
+	p->finalRelPos.set (0,
+			    static_polygon * (-p->centerPosStart.y () + screen_height),
+			    0);
+        if (p->finalRelPos.y ())
+            p->finalRotAng = RAND_FLOAT() * 120 * ( RAND_FLOAT() < 0.5 ? -1 : 1 );
+    }
+}
+
diff -Npur compiz-0.9.13.0.orig/plugins/animationplus/VERSION compiz-0.9.13.0/plugins/animationplus/VERSION
--- compiz-0.9.13.0.orig/plugins/animationplus/VERSION	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/animationplus/VERSION	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1 @@
+0.9.5.0
diff -Npur compiz-0.9.13.0.orig/plugins/composite/src/privates.h compiz-0.9.13.0/plugins/composite/src/privates.h
--- compiz-0.9.13.0.orig/plugins/composite/src/privates.h	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/plugins/composite/src/privates.h	2016-10-15 10:09:09.000000000 +0200
@@ -142,7 +142,6 @@ class PrivateCompositeWindow :
 {
     public:
 	PrivateCompositeWindow (CompWindow *w, CompositeWindow *cw);
-	~PrivateCompositeWindow ();
 
 	void windowNotify (CompWindowNotify n);
 	void resizeNotify (int dx, int dy, int dwidth, int dheight);
@@ -156,11 +155,7 @@ class PrivateCompositeWindow :
 	void allowFurtherRebindAttempts ();
 	bool frozen ();
 
-	static void handleDamageRect (CompositeWindow *w,
-				      int             x,
-				      int             y,
-				      int             width,
-				      int             height);
+	static void handleDamageRect (CompositeWindow *w, XRectangle const& rect);
 
     public:
 	CompWindow      *window;
@@ -179,9 +174,7 @@ class PrivateCompositeWindow :
 	unsigned short brightness;
 	unsigned short saturation;
 
-	XRectangle *damageRects;
-	int        sizeDamage;
-	int        nDamage;
+	std::vector<XRectangle> damageRects;
 
     private:
 
diff -Npur compiz-0.9.13.0.orig/plugins/composite/src/window.cpp compiz-0.9.13.0/plugins/composite/src/window.cpp
--- compiz-0.9.13.0.orig/plugins/composite/src/window.cpp	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/plugins/composite/src/window.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -115,20 +115,11 @@ PrivateCompositeWindow::PrivateComposite
     overlayWindow (false),
     opacity (OPAQUE),
     brightness (BRIGHT),
-    saturation (COLOR),
-    damageRects (0),
-    sizeDamage (0),
-    nDamage (0)
+    saturation (COLOR)
 {
     WindowInterface::setHandler (w);
 }
 
-PrivateCompositeWindow::~PrivateCompositeWindow ()
-{
-    if (sizeDamage)
-	free (damageRects);
-}
-
 bool
 PrivateCompositeWindow::bind ()
 {
@@ -405,32 +396,14 @@ void
 CompositeWindow::processDamage (XDamageNotifyEvent *de)
 {
     if (priv->window->syncWait ())
-    {
-	if (priv->nDamage == priv->sizeDamage)
-	{
-	    priv->damageRects = (XRectangle *) realloc (priv->damageRects,
-				 (priv->sizeDamage + 1) *
-				 sizeof (XRectangle));
-	    priv->sizeDamage += 1;
-	}
-
-	priv->damageRects[priv->nDamage].x      = de->area.x;
-	priv->damageRects[priv->nDamage].y      = de->area.y;
-	priv->damageRects[priv->nDamage].width  = de->area.width;
-	priv->damageRects[priv->nDamage].height = de->area.height;
-	priv->nDamage++;
-    }
+	priv->damageRects.push_back (de->area);
     else
-	priv->handleDamageRect (this, de->area.x, de->area.y,
-				de->area.width, de->area.height);
+	priv->handleDamageRect (this, de->area);
 }
 
 void
 PrivateCompositeWindow::handleDamageRect (CompositeWindow *w,
-					  int             x,
-					  int             y,
-					  int             width,
-					  int             height)
+					  XRectangle const& rect)
 {
     if (!w->priv->redirected)
 	return;
@@ -440,15 +413,15 @@ PrivateCompositeWindow::handleDamageRect
     if (!w->priv->damaged)
 	w->priv->damaged = initial = true;
 
-    if (!w->damageRect (initial, CompRect (x, y, width, height)))
+    if (!w->damageRect (initial, CompRect (rect.x, rect.y, rect.width, rect.height)))
     {
 	const CompWindow::Geometry &geom = w->priv->window->geometry ();
 
-	x += geom.x () + geom.border ();
-	y += geom.y () + geom.border ();
+	int x = rect.x + geom.x () + geom.border ();
+	int y = rect.y + geom.y () + geom.border ();
 
 	w->priv->cScreen->damageRegion (CompRegion (CompRect
-						    (x, y, width, height)));
+						    (x, y, rect.width, rect.height)));
     }
 
     if (initial)
@@ -565,17 +538,10 @@ PrivateCompositeWindow::windowNotify (Co
 
 	case CompWindowNotifySyncAlarm:
 	{
-	    XRectangle *rects;
+	    for (XRectangle const& rect : damageRects)
+		PrivateCompositeWindow::handleDamageRect (cWindow, rect);
 
-	    rects   = damageRects;
-	    while (nDamage--)
-	    {
-		PrivateCompositeWindow::handleDamageRect (cWindow,
-							  rects[nDamage].x,
-							  rects[nDamage].y,
-							  rects[nDamage].width,
-							  rects[nDamage].height);
-	    }
+	    damageRects.clear();
 	    break;
 	}
 
diff -Npur compiz-0.9.13.0.orig/plugins/expo/expo.xml.in compiz-0.9.13.0/plugins/expo/expo.xml.in
--- compiz-0.9.13.0.orig/plugins/expo/expo.xml.in	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/plugins/expo/expo.xml.in	2016-10-15 10:09:09.000000000 +0200
@@ -95,7 +95,7 @@
 		    <_long>The animation used when initiating or leaving Expo.</_long>
 		    <default>0</default>
 		    <min>0</min>
-		    <max>2</max>
+		    <max>3</max>
 		    <desc>
 			<value>0</value>
 			<_name>Zoom</_name>
@@ -108,6 +108,10 @@
 			<value>2</value>
 			<_name>Vortex</_name>
 		    </desc>
+		    <desc>
+			<value>3</value>
+			<_name>None</_name>
+		    </desc>
 		</option>
 	    </group>
 	    <group>
diff -Npur compiz-0.9.13.0.orig/plugins/expo/src/expo.cpp compiz-0.9.13.0/plugins/expo/src/expo.cpp
--- compiz-0.9.13.0.orig/plugins/expo/src/expo.cpp	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/plugins/expo/src/expo.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -92,7 +92,8 @@ ExpoScreen::doExpo (CompAction         *
 		    CompAction::State  state,
 		    CompOption::Vector &options)
 {
-    if (screen->otherGrabExist ("expo", NULL))
+    if (screen->otherGrabExist ("expo", NULL) || 
+	(screen->vpSize ().width () == 1 && screen->vpSize ().height () == 1))
 	return false;
 
     if (!expoMode)
@@ -186,6 +187,10 @@ ExpoScreen::nextVp (CompAction         *
     if (!expoMode)
 	return false;
 
+    CompPoint pointer (pointerX, pointerY);
+    if (!screen->workArea ().contains (pointer))
+	return false;
+
     unsigned int newX = selectedVp.x () + 1;
     unsigned int newY = selectedVp.y ();
 
@@ -213,6 +218,10 @@ ExpoScreen::prevVp (CompAction         *
     if (!expoMode)
 	return false;
 
+    CompPoint pointer (pointerX, pointerY);
+    if (!screen->workArea ().contains (pointer))
+	return false;
+
     int newX = selectedVp.x () - 1;
     int newY = selectedVp.y ();
 
@@ -402,10 +411,18 @@ ExpoScreen::preparePaint (int msSinceLas
     float val = (static_cast <float> (msSinceLastPaint) / 1000.0f) /
 		optionGetZoomTime ();
 
-    if (expoMode)
-	expoCam = MIN (1.0, expoCam + val);
-    else
-	expoCam = MAX (0.0, expoCam - val);
+    if (optionGetExpoAnimation() != ExpoScreen::ExpoAnimationNone) {
+	if (expoMode)
+	    expoCam = MIN (1.0, expoCam + val);
+	else
+	    expoCam = MAX (0.0, expoCam - val);
+    }
+    else {
+	if (expoMode)
+	    expoCam = 1;
+	else
+	    expoCam = 0;
+    }
 
     if (expoCam)
     {
diff -Npur compiz-0.9.13.0.orig/plugins/ezoom/ezoom.xml.in compiz-0.9.13.0/plugins/ezoom/ezoom.xml.in
--- compiz-0.9.13.0.orig/plugins/ezoom/ezoom.xml.in	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/plugins/ezoom/ezoom.xml.in	2016-10-15 10:09:09.000000000 +0200
@@ -81,49 +81,218 @@
 	    </group>
 	    <group>
 		<_short>Specific Zoom</_short>
+		<option type="bool" name="spec_target_focus">
+		    <_short>Target Focused Window on Specific Zoom</_short>
+		    <_long>Check this to target the focused window when jumping to a specific zoom level. Uncheck this to target the mouse.</_long>
+		    <default>true</default>
+		</option>
+		<option type="float" name="zoom_specific_1">
+		    <_short>Specific Zoom 1</_short>
+		    <_long>Zoom level to go to when triggering hotkey 1</_long>
+		    <default>1.0</default>
+		    <min>0.1</min>
+		    <max>1.0</max>
+		    <precision>0.01</precision>
+		</option>
 		<option type="key" name="zoom_specific_1_key">
-		    <_short>Zoom Specific Level 1</_short>
+		    <_short>Zoom to Specific Zoom 1</_short>
 		    <_long>Zoom to the specific zoom level 1</_long>
 		    <default></default>
 		</option>
-		<option type="float" name="zoom_spec1">
-		    <_short>Specific zoom factor 1</_short>
-		    <_long>Zoom level to go to when triggering hotkey 1</_long>
+		<option type="float" name="zoom_specific_2">
+		    <_short>Specific Zoom 2</_short>
+		    <_long>Zoom level to go to when triggering hotkey 2</_long>
 		    <default>1.0</default>
 		    <min>0.1</min>
 		    <max>1.0</max>
 		    <precision>0.01</precision>
 		</option>
 		<option type="key" name="zoom_specific_2_key">
-		    <_short>Zoom Specific Level 2</_short>
+		    <_short>Zoom to Specific Zoom 2</_short>
 		    <_long>Zoom to the specific zoom level 2</_long>
 		    <default></default>
 		</option>
-		<option type="float" name="zoom_spec2">
-		    <_short>Specific zoom factor 2</_short>
-		    <_long>Zoom level to go to when triggering hotkey 2</_long>
-		    <default>0.5</default>
+		<option type="float" name="zoom_specific_3">
+		    <_short>Specific Zoom 3</_short>
+		    <_long>Zoom level to go to when triggering hotkey 3</_long>
+		    <default>1.0</default>
 		    <min>0.1</min>
 		    <max>1.0</max>
 		    <precision>0.01</precision>
 		</option>
 		<option type="key" name="zoom_specific_3_key">
-		    <_short>Zoom Specific Level 3</_short>
+		    <_short>Zoom to Specific Zoom 3</_short>
 		    <_long>Zoom to the specific zoom level 3</_long>
 		    <default></default>
 		</option>
-		<option type="float" name="zoom_spec3">
-		    <_short>Specific zoom factor 3</_short>
-		    <_long>Zoom level to go to when triggering hotkey 3</_long>
-		    <default>0.2</default>
+		<option type="float" name="zoom_specific_4">
+		    <_short>Specific Zoom 4</_short>
+		    <_long>Zoom level to go to when triggering hotkey 4</_long>
+		    <default>1.0</default>
 		    <min>0.1</min>
 		    <max>1.0</max>
 		    <precision>0.01</precision>
 		</option>
-		<option type="bool" name="spec_target_focus">
-		    <_short>Target Focused Window on Specific level</_short>
-		    <_long>Enable this to target the focused window when jumping to a specific zoom level. Disable to target mouse.</_long>
-		    <default>true</default>
+		<option type="key" name="zoom_specific_4_key">
+		    <_short>Zoom to Specific Zoom 4</_short>
+		    <_long>Zoom to the specific zoom level 4</_long>
+		    <default></default>
+		</option>
+		<option type="float" name="zoom_specific_5">
+		    <_short>Specific Zoom 5</_short>
+		    <_long>Zoom level to go to when triggering hotkey 5</_long>
+		    <default>1.0</default>
+		    <min>0.1</min>
+		    <max>1.0</max>
+		    <precision>0.01</precision>
+		</option>
+		<option type="key" name="zoom_specific_5_key">
+		    <_short>Zoom to Specific Zoom 5</_short>
+		    <_long>Zoom to the specific zoom level 5</_long>
+		    <default></default>
+		</option>
+		<option type="float" name="zoom_specific_6">
+		    <_short>Specific Zoom 6</_short>
+		    <_long>Zoom level to go to when triggering hotkey 6</_long>
+		    <default>1.0</default>
+		    <min>0.1</min>
+		    <max>1.0</max>
+		    <precision>0.01</precision>
+		</option>
+		<option type="key" name="zoom_specific_6_key">
+		    <_short>Zoom to Specific Zoom 6</_short>
+		    <_long>Zoom to the specific zoom level 6</_long>
+		    <default></default>
+		</option>
+		<option type="float" name="zoom_specific_7">
+		    <_short>Specific Zoom 7</_short>
+		    <_long>Zoom level to go to when triggering hotkey 7</_long>
+		    <default>1.0</default>
+		    <min>0.1</min>
+		    <max>1.0</max>
+		    <precision>0.01</precision>
+		</option>
+		<option type="key" name="zoom_specific_7_key">
+		    <_short>Zoom to Specific Zoom 7</_short>
+		    <_long>Zoom to the specific zoom level 7</_long>
+		    <default></default>
+		</option>
+		<option type="float" name="zoom_specific_8">
+		    <_short>Specific Zoom 8</_short>
+		    <_long>Zoom level to go to when triggering hotkey 8</_long>
+		    <default>1.0</default>
+		    <min>0.1</min>
+		    <max>1.0</max>
+		    <precision>0.01</precision>
+		</option>
+		<option type="key" name="zoom_specific_8_key">
+		    <_short>Zoom to Specific Zoom 8</_short>
+		    <_long>Zoom to the specific zoom level 8</_long>
+		    <default></default>
+		</option>
+		<option type="float" name="zoom_specific_9">
+		    <_short>Specific Zoom 9</_short>
+		    <_long>Zoom level to go to when triggering hotkey 9</_long>
+		    <default>1.0</default>
+		    <min>0.1</min>
+		    <max>1.0</max>
+		    <precision>0.01</precision>
+		</option>
+		<option type="key" name="zoom_specific_9_key">
+		    <_short>Zoom to Specific Zoom 9</_short>
+		    <_long>Zoom to the specific zoom level 9</_long>
+		    <default></default>
+		</option>
+		<option type="float" name="zoom_specific_10">
+		    <_short>Specific Zoom 10</_short>
+		    <_long>Zoom level to go to when triggering hotkey 10</_long>
+		    <default>1.0</default>
+		    <min>0.1</min>
+		    <max>1.0</max>
+		    <precision>0.01</precision>
+		</option>
+		<option type="key" name="zoom_specific_10_key">
+		    <_short>Zoom to Specific Zoom 10</_short>
+		    <_long>Zoom to the specific zoom level 10</_long>
+		    <default></default>
+		</option>
+		<option type="float" name="zoom_specific_11">
+		    <_short>Specific Zoom 11</_short>
+		    <_long>Zoom level to go to when triggering hotkey 11</_long>
+		    <default>1.0</default>
+		    <min>0.1</min>
+		    <max>1.0</max>
+		    <precision>0.01</precision>
+		</option>
+		<option type="key" name="zoom_specific_11_key">
+		    <_short>Zoom to Specific Zoom 11</_short>
+		    <_long>Zoom to the specific zoom level 11</_long>
+		    <default></default>
+		</option>
+		<option type="float" name="zoom_specific_12">
+		    <_short>Specific Zoom 12</_short>
+		    <_long>Zoom level to go to when triggering hotkey 12</_long>
+		    <default>1.0</default>
+		    <min>0.1</min>
+		    <max>1.0</max>
+		    <precision>0.01</precision>
+		</option>
+		<option type="key" name="zoom_specific_12_key">
+		    <_short>Zoom to Specific Zoom 12</_short>
+		    <_long>Zoom to the specific zoom level 12</_long>
+		    <default></default>
+		</option>
+		<option type="float" name="zoom_specific_13">
+		    <_short>Specific Zoom 13</_short>
+		    <_long>Zoom level to go to when triggering hotkey 13</_long>
+		    <default>1.0</default>
+		    <min>0.1</min>
+		    <max>1.0</max>
+		    <precision>0.01</precision>
+		</option>
+		<option type="key" name="zoom_specific_13_key">
+		    <_short>Zoom to Specific Zoom 13</_short>
+		    <_long>Zoom to the specific zoom level 13</_long>
+		    <default></default>
+		</option>
+		<option type="float" name="zoom_specific_14">
+		    <_short>Specific Zoom 14</_short>
+		    <_long>Zoom level to go to when triggering hotkey 14</_long>
+		    <default>1.0</default>
+		    <min>0.1</min>
+		    <max>1.0</max>
+		    <precision>0.01</precision>
+		</option>
+		<option type="key" name="zoom_specific_14_key">
+		    <_short>Zoom to Specific Zoom 14</_short>
+		    <_long>Zoom to the specific zoom level 14</_long>
+		    <default></default>
+		</option>
+		<option type="float" name="zoom_specific_15">
+		    <_short>Specific Zoom 15</_short>
+		    <_long>Zoom level to go to when triggering hotkey 15</_long>
+		    <default>1.0</default>
+		    <min>0.1</min>
+		    <max>1.0</max>
+		    <precision>0.01</precision>
+		    </option>
+		    <option type="key" name="zoom_specific_15_key">
+		    <_short>Zoom to Specific Zoom 15</_short>
+		    <_long>Zoom to the specific zoom level 15</_long>
+		    <default></default>
+		</option>
+		<option type="float" name="zoom_specific_16">
+		    <_short>Specific Zoom 16</_short>
+		    <_long>Zoom level to go to when triggering hotkey 16</_long>
+		    <default>1.0</default>
+		    <min>0.1</min>
+		    <max>1.0</max>
+		    <precision>0.01</precision>
+		</option>
+		<option type="key" name="zoom_specific_16_key">
+		    <_short>Zoom to Specific Zoom 16</_short>
+		    <_long>Zoom to the specific zoom level 16</_long>
+		    <default></default>
 		</option>
 	    </group>
 	    <group>
diff -Npur compiz-0.9.13.0.orig/plugins/ezoom/src/ezoom.cpp compiz-0.9.13.0/plugins/ezoom/src/ezoom.cpp
--- compiz-0.9.13.0.orig/plugins/ezoom/src/ezoom.cpp	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/plugins/ezoom/src/ezoom.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -1591,16 +1591,68 @@ EZoomScreen::zoomSpecific (CompAction
 
     switch (target)
     {
-	case ZoomTargetFirst:
-	    zoom_level = optionGetZoomSpec1 ();
+	case ZoomTarget1:
+	    zoom_level = optionGetZoomSpecific1 ();
 	    break;
 
-	case ZoomTargetSecond:
-	    zoom_level = optionGetZoomSpec2 ();
+	case ZoomTarget2:
+	    zoom_level = optionGetZoomSpecific2 ();
 	    break;
 
-	case ZoomTargetThird:
-	    zoom_level = optionGetZoomSpec3 ();
+	case ZoomTarget3:
+	    zoom_level = optionGetZoomSpecific3 ();
+	    break;
+
+	case ZoomTarget4:
+	    zoom_level = optionGetZoomSpecific4 ();
+	    break;
+
+	case ZoomTarget5:
+	    zoom_level = optionGetZoomSpecific5 ();
+	    break;
+
+	case ZoomTarget6:
+	    zoom_level = optionGetZoomSpecific6 ();
+	    break;
+
+	case ZoomTarget7:
+	    zoom_level = optionGetZoomSpecific7 ();
+	    break;
+
+	case ZoomTarget8:
+	    zoom_level = optionGetZoomSpecific8 ();
+	    break;
+
+	case ZoomTarget9:
+	    zoom_level = optionGetZoomSpecific9 ();
+	    break;
+
+	case ZoomTarget10:
+	    zoom_level = optionGetZoomSpecific10 ();
+	    break;
+
+	case ZoomTarget11:
+	    zoom_level = optionGetZoomSpecific11 ();
+	    break;
+
+	case ZoomTarget12:
+	    zoom_level = optionGetZoomSpecific12 ();
+	    break;
+
+	case ZoomTarget13:
+	    zoom_level = optionGetZoomSpecific13 ();
+	    break;
+
+	case ZoomTarget14:
+	    zoom_level = optionGetZoomSpecific14 ();
+	    break;
+
+	case ZoomTarget15:
+	    zoom_level = optionGetZoomSpecific15 ();
+	    break;
+
+	case ZoomTarget16:
+	    zoom_level = optionGetZoomSpecific16 ();
 	    break;
 
 	default:
@@ -1966,16 +2018,54 @@ EZoomScreen::EZoomScreen (CompScreen *sc
     optionSetZoomOutKeyInitiate (boost::bind (&EZoomScreen::zoomOut, this, _1,
 						_2, _3));
 
-    optionSetZoomSpecific1KeyInitiate (boost::bind (&EZoomScreen::zoomSpecific,
-						    this, _1, _2, _3,
-						    ZoomTargetFirst));
-    optionSetZoomSpecific2KeyInitiate (boost::bind (&EZoomScreen::zoomSpecific,
-						    this, _1, _2, _3,
-						    ZoomTargetSecond));
-    optionSetZoomSpecific3KeyInitiate (boost::bind (&EZoomScreen::zoomSpecific,
-						    this, _1, _2, _3,
-						    ZoomTargetThird));
-
+    optionSetZoomSpecific1KeyInitiate (boost::bind (&EZoomScreen::zoomSpecific, 
+                                       this, _1, _2, _3, 
+                                       ZoomTarget1));
+    optionSetZoomSpecific2KeyInitiate (boost::bind (&EZoomScreen::zoomSpecific, 
+                                       this, _1, _2, _3, 
+                                       ZoomTarget2));
+    optionSetZoomSpecific3KeyInitiate (boost::bind (&EZoomScreen::zoomSpecific, 
+                                       this, _1, _2, _3, 
+                                       ZoomTarget3));
+    optionSetZoomSpecific4KeyInitiate (boost::bind (&EZoomScreen::zoomSpecific, 
+                                       this, _1, _2, _3, 
+                                       ZoomTarget4));
+    optionSetZoomSpecific5KeyInitiate (boost::bind (&EZoomScreen::zoomSpecific, 
+                                       this, _1, _2, _3, 
+                                       ZoomTarget5));
+    optionSetZoomSpecific6KeyInitiate (boost::bind (&EZoomScreen::zoomSpecific, 
+                                       this, _1, _2, _3, 
+                                       ZoomTarget6));
+    optionSetZoomSpecific7KeyInitiate (boost::bind (&EZoomScreen::zoomSpecific, 
+                                       this, _1, _2, _3, 
+                                       ZoomTarget7));
+    optionSetZoomSpecific8KeyInitiate (boost::bind (&EZoomScreen::zoomSpecific, 
+                                       this, _1, _2, _3, 
+                                       ZoomTarget8));
+    optionSetZoomSpecific9KeyInitiate (boost::bind (&EZoomScreen::zoomSpecific, 
+                                       this, _1, _2, _3, 
+                                       ZoomTarget9));
+    optionSetZoomSpecific10KeyInitiate (boost::bind (&EZoomScreen::zoomSpecific, 
+                                        this, _1, _2, _3, 
+                                        ZoomTarget10));
+    optionSetZoomSpecific11KeyInitiate (boost::bind (&EZoomScreen::zoomSpecific, 
+                                        this, _1, _2, _3, 
+                                        ZoomTarget11));
+    optionSetZoomSpecific12KeyInitiate (boost::bind (&EZoomScreen::zoomSpecific, 
+                                        this, _1, _2, _3, 
+                                        ZoomTarget12));
+    optionSetZoomSpecific13KeyInitiate (boost::bind (&EZoomScreen::zoomSpecific, 
+                                        this, _1, _2, _3, 
+                                        ZoomTarget13));
+    optionSetZoomSpecific14KeyInitiate (boost::bind (&EZoomScreen::zoomSpecific, 
+                                        this, _1, _2, _3, 
+                                        ZoomTarget14));
+    optionSetZoomSpecific15KeyInitiate (boost::bind (&EZoomScreen::zoomSpecific, 
+                                        this, _1, _2, _3, 
+                                        ZoomTarget15));
+    optionSetZoomSpecific16KeyInitiate (boost::bind (&EZoomScreen::zoomSpecific, 
+                                        this, _1, _2, _3, 
+                                        ZoomTarget16));
     optionSetPanLeftKeyInitiate (boost::bind (&EZoomScreen::zoomPan, this, _1,
 					      _2, _3, -1, 0));
     optionSetPanRightKeyInitiate (boost::bind (&EZoomScreen::zoomPan, this, _1,
diff -Npur compiz-0.9.13.0.orig/plugins/ezoom/src/ezoom.h compiz-0.9.13.0/plugins/ezoom/src/ezoom.h
--- compiz-0.9.13.0.orig/plugins/ezoom/src/ezoom.h	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/plugins/ezoom/src/ezoom.h	2016-10-15 10:09:09.000000000 +0200
@@ -51,9 +51,22 @@
 
 enum SpecificZoomTarget
 {
-    ZoomTargetFirst = 0,
-    ZoomTargetSecond,
-    ZoomTargetThird
+    ZoomTarget1 = 0,
+    ZoomTarget2,
+    ZoomTarget3,
+    ZoomTarget4,
+    ZoomTarget5,
+    ZoomTarget6,
+    ZoomTarget7,
+    ZoomTarget8,
+    ZoomTarget9,
+    ZoomTarget10,
+    ZoomTarget11,
+    ZoomTarget12,
+    ZoomTarget13,
+    ZoomTarget14,
+    ZoomTarget15,
+    ZoomTarget16
 };
 
 class EZoomScreen :
diff -Npur compiz-0.9.13.0.orig/plugins/gnomecompat/gnomecompat.xml.in compiz-0.9.13.0/plugins/gnomecompat/gnomecompat.xml.in
--- compiz-0.9.13.0.orig/plugins/gnomecompat/gnomecompat.xml.in	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/plugins/gnomecompat/gnomecompat.xml.in	2016-10-15 10:09:09.000000000 +0200
@@ -11,6 +11,9 @@
 		<plugin>opengl</plugin>
 		<plugin>decor</plugin>
 	    </relation>
+	    <conflict>
+		<plugin>unityshell</plugin>
+	    </conflict>
 	</deps>
 	<options>
 	    <option name="main_menu_key" type="key">
diff -Npur compiz-0.9.13.0.orig/plugins/grid/src/grid.cpp compiz-0.9.13.0/plugins/grid/src/grid.cpp
--- compiz-0.9.13.0.orig/plugins/grid/src/grid.cpp	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/plugins/grid/src/grid.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -250,110 +250,130 @@ GridScreen::initiateCommon (CompAction
 	      !optionGetCycleSizes ())) &&
 	    gw->lastTarget & where)
 	{
+	    /* TODO: 
+	     * instead of just using what was here
+	     * decide on how to deal with rounding/truncating/off by one, 
+	     * might be helpful in cases like using a windowed virtual machine
+	     * with a relatively prime number for width, 
+	     * examples 631, 797, 1021, 1279, 1439, 1913, 2039, 2557, 3833, ... NextPrime[{N}, -1] 
+	     */
+	    int slotWidth12  = workarea.width () / 8;
+	    int slotWidth17  = (workarea.width () / 6);
 	    int slotWidth25  = workarea.width () / 4;
 	    int slotWidth33  = (workarea.width () / 3) + cw->border ().left;
-	    int slotWidth17  = slotWidth33 - slotWidth25;
+	    int slotWidth50  = (workarea.width () / 2);
 	    int slotWidth66  = workarea.width () - slotWidth33;
 	    int slotWidth75  = workarea.width () - slotWidth25;
+	    int slotWidth100 = workarea.width ();
+	    int slotWidth37  = slotWidth75 / 2;
 
 	    if (props.numCellsX == 2) /* keys (1, 4, 7, 3, 6, 9) */
 	    {
-		if ((currentRect.width () == desiredRect.width () &&
-		     currentRect.x () == desiredRect.x ()) ||
-		    (gw->resizeCount < 1) || (gw->resizeCount > 5))
-		    gw->resizeCount = 3;
-
+		if ((currentRect.width () ==  desiredRect.width ()  &&
+		     currentRect.x ()     ==  desiredRect.x ())     ||
+		    (gw->resizeCount < 1) || (gw->resizeCount > 6))
+		{
+		    gw->resizeCount = 2;
+		}
 		/* tricky, have to allow for window constraints when
 		 * computing what the 33% and 66% offsets would be
 		 */
 		switch (gw->resizeCount)
 		{
 		    case 1:
-			desiredSlot.setWidth (slotWidth66);
-			desiredSlot.setX (workarea.x () +
-					  props.gravityRight * slotWidth33);
-			++gw->resizeCount;
-			break;
-
+		    desiredSlot.setWidth (slotWidth50);
+		    desiredSlot.setX (workarea.x () +  props.gravityRight * slotWidth50);
+		    ++gw->resizeCount;
+		    break;
+                
 		    case 2:
-			++gw->resizeCount;
-			break;
-
+		    desiredSlot.setWidth (slotWidth33);
+		    desiredSlot.setX (workarea.x () + props.gravityRight * slotWidth66);
+		    ++gw->resizeCount;
+		    break;
+                
 		    case 3:
-			desiredSlot.setWidth (slotWidth33);
-			desiredSlot.setX (workarea.x () +
-					  props.gravityRight * slotWidth66);
-			++gw->resizeCount;
-			break;
-
+		    desiredSlot.setWidth (slotWidth25);
+		    desiredSlot.setX (workarea.x () + props.gravityRight * slotWidth75);
+		    ++gw->resizeCount;
+		    break;
+                
 		    case 4:
-			desiredSlot.setWidth (slotWidth25);
-			desiredSlot.setX (workarea.x () +
-					  props.gravityRight * slotWidth75);
-			++gw->resizeCount;
-			break;
-
+		    desiredSlot.setWidth (slotWidth100);
+		    desiredSlot.setX (workarea.x ());
+		    ++gw->resizeCount;
+		    break;
+                
 		    case 5:
-			desiredSlot.setWidth (slotWidth75);
-			desiredSlot.setX (workarea.x () +
-					  props.gravityRight * slotWidth25);
-			++gw->resizeCount;
-			break;
-
+		    desiredSlot.setWidth (slotWidth75);
+		    desiredSlot.setX (workarea.x () + props.gravityRight * slotWidth25);
+		    ++gw->resizeCount;
+		    break;
+                
+		    case 6:
+		    desiredSlot.setWidth (slotWidth66);
+		    desiredSlot.setX (workarea.x () + props.gravityRight * slotWidth33);
+		    ++gw->resizeCount;
+		    break;
+                
 		    default:
-			break;
+		    break;
 		}
 	    }
 	    else /* keys (2, 5, 8) */
 	    {
-		if ((currentRect.width () == desiredRect.width () &&
-		     currentRect.x () == desiredRect.x ()) ||
-		    (gw->resizeCount < 1) || (gw->resizeCount > 5))
-		    gw->resizeCount = 1;
-
+		if ((currentRect.width () ==  desiredRect.width ()  &&
+		     currentRect.x ()     ==  desiredRect.x ())     ||
+		    (gw->resizeCount < 1) || (gw->resizeCount > 6))
+		{
+		    gw->resizeCount = 2;
+		}
 		switch (gw->resizeCount)
 		{
 		    case 1:
-			desiredSlot.setWidth (workarea.width () -
-					      (slotWidth17 * 2));
-			desiredSlot.setX (workarea.x () + slotWidth17);
-			++gw->resizeCount;
-			break;
-
+		    desiredSlot.setWidth (slotWidth100);
+		    desiredSlot.setX (workarea.x ());
+		    ++gw->resizeCount;
+		    break;
+		    
 		    case 2:
-			desiredSlot.setWidth ((slotWidth25 * 2) +
-					      (slotWidth17 * 2));
-			desiredSlot.setX (workarea.x () +
-					  (slotWidth25 - slotWidth17));
-			++gw->resizeCount;
-			break;
-
+		    desiredSlot.setWidth (slotWidth75);
+		    desiredSlot.setX (workarea.x () + slotWidth12);
+		    ++gw->resizeCount;
+		    break;
+                
 		    case 3:
-			desiredSlot.setWidth ((slotWidth25 * 2));
-			desiredSlot.setX (workarea.x () + slotWidth25);
-			++gw->resizeCount;
-			break;
-
+		    desiredSlot.setWidth (slotWidth66);
+		    desiredSlot.setX (workarea.x () + slotWidth17);
+		    ++gw->resizeCount;
+		    break;
+                
 		    case 4:
-			desiredSlot.setWidth (slotWidth33 -
-					      (cw->border ().left +
-					       cw->border ().right));
-			desiredSlot.setX (workarea.x () + slotWidth33);
-			++gw->resizeCount;
-			break;
-
+		    desiredSlot.setWidth ((slotWidth50));
+		    desiredSlot.setX (workarea.x () + slotWidth25);
+		    ++gw->resizeCount;
+		    break;
+                
 		    case 5:
-			++gw->resizeCount;
-			break;
-
+		    desiredSlot.setWidth (slotWidth33 - (cw->border ().left + cw->border ().right));
+		    desiredSlot.setX (workarea.x () + slotWidth33);
+		    ++gw->resizeCount;
+		    break;
+                
+		    case 6:
+		    desiredSlot.setWidth ((slotWidth25));
+		    desiredSlot.setX (workarea.x () + slotWidth37);
+		    ++gw->resizeCount;
+		    break;
+                
 		    default:
-			break;
+		    break;
 		}
 	    }
-
-	    if (gw->resizeCount == 6)
+	    if (gw->resizeCount > 6)
+	    {
 		gw->resizeCount = 1;
-
+	    }
 	    desiredRect = constrainSize (cw, desiredSlot);
 	}
 
diff -Npur compiz-0.9.13.0.orig/plugins/opengl/src/vertexbuffer.cpp compiz-0.9.13.0/plugins/opengl/src/vertexbuffer.cpp
--- compiz-0.9.13.0.orig/plugins/opengl/src/vertexbuffer.cpp	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/plugins/opengl/src/vertexbuffer.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -678,11 +678,12 @@ int PrivateVertexBuffer::legacyRender (c
 			  maxVertices) :
 		vertexData.size () / 3;
 
-    if (indices && nIndices)
+    if (indices && nIndices) {
 	glDrawElements (primitiveType,
 			nIndices,
 			GL_UNSIGNED_SHORT,
 			indices);
+    }
     else
  	glDrawArrays (primitiveType, vertexOffset, nVerticesToDraw);
 
diff -Npur compiz-0.9.13.0.orig/plugins/scale/scale.xml.in compiz-0.9.13.0/plugins/scale/scale.xml.in
--- compiz-0.9.13.0.orig/plugins/scale/scale.xml.in	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/plugins/scale/scale.xml.in	2016-10-15 10:09:09.000000000 +0200
@@ -139,6 +139,11 @@
 					<_name>On all output devices</_name>
 				</desc>
 			</option>
+			<option name="skip_animation" type="bool">
+				<_short>Skip Animation</_short>
+				<_long>Skips the scale plugin animation.</_long>
+				<default>false</default>
+			</option>
 	    </group>
 	    <group>
 		<_short>Bindings</_short>
diff -Npur compiz-0.9.13.0.orig/plugins/scale/src/scale.cpp compiz-0.9.13.0/plugins/scale/src/scale.cpp
--- compiz-0.9.13.0.orig/plugins/scale/src/scale.cpp	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/plugins/scale/src/scale.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -932,9 +932,11 @@ PrivateScaleScreen::preparePaint (int ms
     if (state != ScaleScreen::Idle && state != ScaleScreen::Wait)
     {
 	int   steps;
-	float amount, chunk;
+	float amount, chunk, speed;
 
-	amount = msSinceLastPaint * 0.05f * optionGetSpeed ();
+	speed = optionGetSkipAnimation() ? USHRT_MAX : optionGetSpeed();
+
+	amount = msSinceLastPaint * 0.05f * speed;
 	steps  = amount / (0.5f * optionGetTimestep ());
 
 	if (!steps)
diff -Npur compiz-0.9.13.0.orig/plugins/showdesktop/showdesktop.xml.in compiz-0.9.13.0/plugins/showdesktop/showdesktop.xml.in
--- compiz-0.9.13.0.orig/plugins/showdesktop/showdesktop.xml.in	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/plugins/showdesktop/showdesktop.xml.in	2016-10-15 10:09:09.000000000 +0200
@@ -100,6 +100,11 @@
           <_long>Window types that should be moved out of sight when entering showdesktop-mode.</_long>
           <default>type=toolbar | type=utility | type=dialog | type=normal</default>
         </option>
+	<option name="skip_animation" type="bool">
+          <_short>Skip Animation</_short>
+	  <_long>Skips the showdesktop animation.</_long>
+	  <default>false</default>
+	</option>
       </group>
       <group>
         <_short>Appearance</_short>
diff -Npur compiz-0.9.13.0.orig/plugins/showdesktop/src/showdesktop.cpp compiz-0.9.13.0/plugins/showdesktop/src/showdesktop.cpp
--- compiz-0.9.13.0.orig/plugins/showdesktop/src/showdesktop.cpp	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/plugins/showdesktop/src/showdesktop.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -614,10 +614,21 @@ ShowdesktopScreen::preparePaint (int msS
 	(state == SD_STATE_DEACTIVATING))
     {
 	int steps;
-	float amount, chunk;
+	float amount, chunk, speed, timestep;
 
-	amount = msSinceLastPaint * 0.05f * optionGetSpeed ();
-	steps = amount / (0.5f * optionGetTimestep ());
+	if (optionGetSkipAnimation())
+	{
+	    speed = USHRT_MAX;
+	    timestep = 0.1;
+	}
+	else
+	{
+	    speed = optionGetSpeed();
+	    timestep = optionGetTimestep();
+	}
+
+	amount = msSinceLastPaint * 0.05f * speed;
+	steps = amount / (0.5f * timestep);
 	if (!steps)
     	    steps = 1;
 	chunk = amount / (float)steps;
diff -Npur compiz-0.9.13.0.orig/plugins/simple-animations/animationsim.xml.in compiz-0.9.13.0/plugins/simple-animations/animationsim.xml.in
--- compiz-0.9.13.0.orig/plugins/simple-animations/animationsim.xml.in	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/simple-animations/animationsim.xml.in	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,235 @@
+<compiz>
+  <plugin name="animationsim" useBcop="true">
+    <_short>Simple Animations</_short>
+    <_long>Animations that are simple on the eye</_long>
+    <category>Effects</category>
+    <deps>
+	<requirement>
+	    <plugin>animation</plugin>
+	</requirement>
+	<relation type="after">
+	    <plugin>animation</plugin>
+	</relation>
+    </deps>
+    <options>
+
+      <group>
+	<_short>Effect Settings</_short>
+
+	<subgroup>
+	  <_short>Fly In</_short>
+	  <option name="flyin_direction" type="int">
+	    <_short>Fly In Direction</_short>
+	    <_long>The direction in which the fly in should take place</_long>
+	    <default>0</default>
+	    <desc>
+		<value>0</value>
+		<name>Up</name>
+	    </desc>
+	    <desc>
+		<value>1</value>
+		<name>Left</name>
+	    </desc>
+	    <desc>
+		<value>2</value>
+		<name>Down</name>
+	    </desc>
+	    <desc>
+		<value>3</value>
+		<name>Right</name>
+	    </desc>
+	    <desc>
+		<value>4</value>
+		<name>User Defined</name>
+	    </desc>
+	    <min>0</min>
+	    <max>4</max>
+	  </option>
+	  <option name="flyin_direction_x" type="float">
+	    <_short>UD Direction X</_short>
+	    <_long>Direction and Distance X for user defined fly in</_long>
+	    <default>0</default>
+	    <min>-1000</min>
+	    <max>1000</max>
+		<precision>0.01</precision>
+	  </option>
+	  <option name="flyin_direction_y" type="float">
+	    <_short>UD Direction Y</_short>
+	    <_long>Direction and Distance Y for user defined fly in</_long>
+	    <default>0</default>
+	    <min>-1000</min>
+	    <max>1000</max>
+		<precision>0.01</precision>
+	  </option>
+	  <option name="flyin_fade" type="bool">
+	    <_short>Fade</_short>
+	    <_long>Fade when flying in</_long>
+	    <default>true</default>
+	  </option>
+	  <option name="flyin_distance" type="float">
+	    <_short>Distance</_short>
+	    <_long>Distance to fly in</_long>
+	    <default>20</default>
+	    <min>5</min>
+	    <max>1000</max>
+		<precision>0.01</precision>
+	  </option>
+	</subgroup>
+	<subgroup>
+	  <_short>Rotate In</_short>
+	  <option name="rotatein_direction" type="int">
+	    <_short>Rotate In Direction</_short>
+	    <_long>The direction in which the window rotates</_long>
+	    <default>3</default>
+	    <desc>
+		<value>1</value>
+		<name>Up</name>
+	    </desc>
+	    <desc>
+		<value>2</value>
+		<name>Left</name>
+	    </desc>
+	    <desc>
+		<value>3</value>
+		<name>Down</name>
+	    </desc>
+	    <desc>
+		<value>4</value>
+		<name>Right</name>
+	    </desc>
+	    <min>1</min>
+	    <max>4</max>
+	  </option>
+	  <option name="rotatein_angle" type="float">
+	    <_short>Angle</_short>
+	    <_long>Angle to start from</_long>
+	    <default>90</default>
+	    <min>-720</min>
+	    <max>720</max>
+	  </option>
+	</subgroup>
+	<subgroup>
+	  <_short>Bounce</_short>
+	  <option name="bounce_max_size" type="float">
+	    <_short>Maximum Size</_short>
+	    <_long>Maximum scale factor of window when bouncing</_long>
+	    <default>1.2</default>
+	    <min>1.0</min>
+	    <max>3.0</max>
+	  </option>
+	  <option name="bounce_min_size" type="float">
+	    <_short>Minimum Size</_short>
+	    <_long>Minimum scale factor of window when bouncing</_long>
+	    <default>0.6</default>
+	    <min>0.1</min>
+	    <max>1.0</max>
+	  </option>
+	  <option name="bounce_number" type="int">
+	    <_short>Number of Bounces</_short>
+	    <_long>How many bounces during the animation</_long>
+	    <default>3</default>
+	    <min>0</min>
+	    <max>10</max>
+	  </option>
+	  <option name="bounce_fade" type="bool">
+	    <_short>Fade</_short>
+	    <_long>Fade when flying in</_long>
+	    <default>true</default>
+	  </option>
+	</subgroup>
+	<subgroup>
+	  <_short>Sheet</_short>
+	  <option name="sheet_start_percent" type="float">
+	    <_short>Starting Percent</_short>
+            <_long>How wide the beginning of the sheet animation should be compared to the end</_long>
+	    <default>80.0</default>
+	    <min>1.0</min>
+	    <max>150.0</max>
+	  </option>
+	</subgroup>
+	<subgroup>
+	  <_short>Fan</_short>
+	  <option name="fan_angle" type="float">
+	    <_short>Fan Angle</_short>
+	    <_long>Angle of windows away from the main window</_long>
+	    <default>35</default>
+	    <min>0</min>
+	    <max>90</max>
+	    <precision>0.1</precision>
+	  </option>
+	</subgroup>
+	<subgroup>
+	  <_short>Expand Piecewise</_short>
+	  <option name="expandpw_horiz_first" type="bool">
+	    <_short>First expand horizontally</_short>
+	    <_long>If checked, initially expand horizontally, then vertically</_long>
+	    <default>true</default>
+	  </option>
+	  <option name="expandpw_initial_horiz" type="int">
+	    <_short>Initial horizontal size</_short>
+	    <_long>Number of pixels initially in horizontal direction</_long>
+	    <default>20</default>
+	    <min>0</min>
+	    <max>50</max>
+	  </option>
+	  <option name="expandpw_initial_vert" type="int">
+	    <_short>Initial vertical size</_short>
+	    <_long>Number of pixels initially in vertical direction</_long>
+	    <default>20</default>
+	    <min>0</min>
+	    <max>50</max>
+	  </option>
+	  <option name="expandpw_delay" type="float">
+	    <_short>Delay</_short>
+	    <_long>Delay between expanding horizontally and vertically (expressed as a fraction)</_long>
+	    <default>0.25</default>
+	    <min>0.0</min>
+	    <max>1.0</max>
+	  </option>
+	</subgroup>
+
+      </group>
+
+    </options>
+
+    <extension base_plugin="animation">
+      <base_option>open_effects</base_option>
+      <base_option>open_random_effects</base_option>
+      <base_option>close_effects</base_option>
+      <base_option>close_random_effects</base_option>
+      <restriction>
+	<value>animationsim:Fly In</value>
+	<_name>Fly In</_name>
+      </restriction>
+      <restriction>
+	<value>animationsim:Bounce</value>
+	<_name>Bounce</_name>
+      </restriction>
+      <restriction>
+	<value>animationsim:Rotate In</value>
+	<_name>Rotate In</_name>
+      </restriction>
+      <restriction>
+	<value>animationsim:Sheet</value>
+	<_name>Sheet</_name>
+      </restriction>
+      <restriction>
+	<value>animationsim:Expand</value>
+	<_name>Expand</_name>
+      </restriction>
+      <restriction>
+	<value>animationsim:Expand Piecewise</value>
+	<_name>Expand Piecewise</_name>
+      </restriction>
+      <restriction>
+	<value>animationsim:Pulse</value>
+	<_name>Pulse</_name>
+      </restriction>
+      <restriction>
+	<value>animationsim:Fan</value>
+	<_name>Fan</_name>
+      </restriction>
+    </extension>
+
+  </plugin>
+</compiz>
diff -Npur compiz-0.9.13.0.orig/plugins/simple-animations/CMakeLists.txt compiz-0.9.13.0/plugins/simple-animations/CMakeLists.txt
--- compiz-0.9.13.0.orig/plugins/simple-animations/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/simple-animations/CMakeLists.txt	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,4 @@
+find_package (Compiz REQUIRED)
+include (CompizPlugin)
+
+compiz_plugin (animationsim PLUGINDEPS composite opengl animation)
diff -Npur compiz-0.9.13.0.orig/plugins/simple-animations/src/animationsim.cpp compiz-0.9.13.0/plugins/simple-animations/src/animationsim.cpp
--- compiz-0.9.13.0.orig/plugins/simple-animations/src/animationsim.cpp	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/simple-animations/src/animationsim.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,164 @@
+/**
+ * Example Animation extension plugin for compiz
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ **/
+
+#include "animationsim.h"
+
+COMPIZ_PLUGIN_20090315 (animationsim, AnimSimPluginVTable);
+
+AnimEffect animEffects[NUM_EFFECTS];
+
+ExtensionPluginAnimSim animSimExtPluginInfo (CompString ("animationsim"),
+					     NUM_EFFECTS, animEffects, NULL,
+                                             NUM_NONEFFECT_OPTIONS);
+
+ExtensionPluginInfo *
+BaseSimAnim::getExtensionPluginInfo ()
+{
+    return &animSimExtPluginInfo;
+}
+
+BaseSimAnim::BaseSimAnim (CompWindow *w,
+			  WindowEvent curWindowEvent,
+			  float duration,
+			  const AnimEffect info,
+			  const CompRect &icon) :
+    Animation::Animation (w, curWindowEvent, duration, info, icon),
+    mCScreen (CompositeScreen::get (::screen)),
+    mGScreen (GLScreen::get (::screen))
+{
+}
+
+AnimEffect AnimEffectFlyIn;
+AnimEffect AnimEffectRotateIn;
+AnimEffect AnimEffectExpand;
+AnimEffect AnimEffectExpandPW;
+AnimEffect AnimEffectBounce;
+AnimEffect AnimEffectSheet;
+AnimEffect AnimEffectPulse;
+AnimEffect AnimEffectFan;
+
+void
+AnimSimScreen::initAnimationList ()
+{
+    int i = 0;
+    AnimEffectUsedFor usedFor = AnimEffectUsedFor::all()
+				.exclude(AnimEventFocus)
+				.exclude(AnimEventShade);
+    AnimEffectUsedFor openUsedFor = AnimEffectUsedFor::all()
+				    .exclude(AnimEventFocus)
+				    .exclude(AnimEventShade)
+				    .exclude(AnimEventMinimize)
+				    .exclude(AnimEventUnminimize);
+
+    animEffects[i++] = AnimEffectFlyIn =
+	new AnimEffectInfo ("animationsim:Fly In", usedFor,
+			    &createAnimation<FlyInAnim>);
+
+    animEffects[i++] = AnimEffectRotateIn =
+	new AnimEffectInfo ("animationsim:Rotate In", usedFor,
+			    &createAnimation<RotateInAnim>);
+
+    animEffects[i++] = AnimEffectExpand =
+	new AnimEffectInfo ("animationsim:Expand", usedFor,
+			    &createAnimation<ExpandAnim>);
+
+    animEffects[i++] = AnimEffectExpandPW =
+	new AnimEffectInfo ("animationsim:Expand Piecewise", usedFor,
+			    &createAnimation<ExpandPWAnim>);
+
+    animEffects[i++] = AnimEffectBounce =
+	new AnimEffectInfo ("animationsim:Bounce", openUsedFor,
+			    &createAnimation<BounceAnim>);
+
+    animEffects[i++] = AnimEffectSheet =
+	new AnimEffectInfo ("animationsim:Sheet", openUsedFor,
+			    &createAnimation<SheetAnim>);
+    animEffects[i++] = AnimEffectPulse =
+	new AnimEffectInfo ("animationsim:Pulse", openUsedFor,
+			    &createAnimation<PulseAnim>);
+    animEffects[i++] = AnimEffectFan =
+	new AnimEffectInfo ("animationsim:Fan", openUsedFor,
+			    &createAnimation<FanAnim>);
+
+    animSimExtPluginInfo.effectOptions = &getOptions ();
+
+    AnimScreen *as = AnimScreen::get (::screen);
+
+    // Extends animation plugin with this set of animation effects.
+    as->addExtension (&animSimExtPluginInfo);
+}
+
+AnimSimScreen::AnimSimScreen (CompScreen *s) :
+    //cScreen (CompositeScreen::get (s)),
+    //gScreen (GLScreen::get (s)),
+    //aScreen (as),
+    PluginClassHandler <AnimSimScreen, CompScreen> (s),
+    mOutput (s->fullscreenOutput ())
+{
+    initAnimationList ();
+}
+
+AnimSimScreen::~AnimSimScreen ()
+{
+    AnimScreen *as = AnimScreen::get (::screen);
+
+    as->removeExtension (&animSimExtPluginInfo);
+
+    for (int i = 0; i < NUM_EFFECTS; i++)
+    {
+	delete animEffects[i];
+	animEffects[i] = NULL;
+    }
+}
+
+AnimSimWindow::AnimSimWindow (CompWindow *w) :
+    PluginClassHandler<AnimSimWindow, CompWindow> (w),
+    mWindow (w),
+    aWindow (AnimWindow::get (w))
+{
+}
+
+AnimSimWindow::~AnimSimWindow ()
+{
+    Animation *curAnim = aWindow->curAnimation ();
+
+    if (!curAnim)
+	return;
+
+    // We need to interrupt and clean up the animation currently being played
+    // by animationsim for this window (if any)
+    if (curAnim->remainingTime () > 0 &&
+	curAnim->getExtensionPluginInfo ()->name ==
+	    CompString ("animationsim"))
+    {
+	aWindow->postAnimationCleanUp ();
+    }
+}
+
+bool
+AnimSimPluginVTable::init ()
+{
+    if (!CompPlugin::checkPluginABI ("core", CORE_ABIVERSION) |
+        !CompPlugin::checkPluginABI ("composite", COMPIZ_COMPOSITE_ABI) |
+        !CompPlugin::checkPluginABI ("opengl", COMPIZ_OPENGL_ABI) |
+        !CompPlugin::checkPluginABI ("animation", ANIMATION_ABI))
+	 return false;
+
+    return true;
+}
diff -Npur compiz-0.9.13.0.orig/plugins/simple-animations/src/animationsim.h compiz-0.9.13.0/plugins/simple-animations/src/animationsim.h
--- compiz-0.9.13.0.orig/plugins/simple-animations/src/animationsim.h	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/simple-animations/src/animationsim.h	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,405 @@
+#include <string.h>
+#include <stdlib.h>
+#include <math.h>
+
+#include <core/core.h>
+#include <composite/composite.h>
+#include <opengl/opengl.h>
+#include <animation/animation.h>
+
+#include "animationsim_options.h"
+
+extern AnimEffect AnimEffectFlyIn;
+extern AnimEffect AnimEffectBounce;
+extern AnimEffect AnimEffectRotateIn;
+extern AnimEffect AnimEffectSheet;
+extern AnimEffect AnimEffectExpand;
+extern AnimEffect AnimEffectExpandPW;
+extern AnimEffect AnimEffectFan;
+
+// TODO Update this for each added animation effect! (total: 8)
+#define NUM_EFFECTS 8
+
+// This must have the value of the first "effect setting" above
+// in AnimAddonScreenOptions
+#define NUM_NONEFFECT_OPTIONS AnimationsimOptions::FlyinDirection
+
+#define WIN_X(w) ((w)->x () - (w)->input ().left)
+#define WIN_Y(w) ((w)->y () - (w)->input ().top)
+#define WIN_W(w) ((w)->width () + (w)->input ().left + (w)->input ().right)
+#define WIN_H(w) ((w)->height () + (w)->input ().top + (w)->input ().bottom)
+
+class ExtensionPluginAnimSim : public ExtensionPluginInfo
+{
+public:
+    ExtensionPluginAnimSim (const CompString &name,
+			    unsigned int nEffects,
+			    AnimEffect *effects,
+			    CompOption::Vector *effectOptions,
+			    unsigned int firstEffectOptionIndex) :
+	ExtensionPluginInfo (name, nEffects, effects, effectOptions,
+			     firstEffectOptionIndex) {}
+    ~ExtensionPluginAnimSim () {}
+
+    const CompOutput *output () { return mOutput; }
+
+private:
+    const CompOutput *mOutput;
+};
+
+/// Base class for all polygon- and particle-based animations
+class BaseSimAnim :
+virtual public Animation
+{
+public:
+    BaseSimAnim (CompWindow *w,
+		   WindowEvent curWindowEvent,
+		   float duration,
+		   const AnimEffect info,
+		   const CompRect &icon);
+    ~BaseSimAnim () {}
+    
+protected:
+    /// Gets info about the extension plugin that implements this animation.
+    ExtensionPluginInfo *getExtensionPluginInfo ();
+    
+    CompositeScreen *mCScreen;
+    GLScreen *mGScreen;
+    
+};
+
+
+class AnimSimScreen :
+    public PluginClassHandler <AnimSimScreen, CompScreen>,
+    public AnimationsimOptions
+{
+
+public:
+    AnimSimScreen (CompScreen *);
+    ~AnimSimScreen ();
+
+protected:
+    void initAnimationList ();
+
+    CompOutput &mOutput;
+};
+
+class AnimSimWindow :
+    public PluginClassHandler<AnimSimWindow, CompWindow>
+{
+public:
+    AnimSimWindow (CompWindow *);
+    ~AnimSimWindow ();
+
+protected:
+    CompWindow *mWindow;    ///< Window being animated.
+    AnimWindow *aWindow;
+};
+
+/*
+typedef struct _WaveParam
+{
+    float halfWidth;
+    float amp;
+    float pos;
+} WaveParam;
+*/
+
+#define ANIMSIM_SCREEN(s)						      \
+    AnimSimScreen *ass = AnimSimScreen::get (s);
+
+#define ANIMSIM_WINDOW(w)						      \
+    AnimSimWindow *asw = AnimSimWindow::get (w);
+
+class FlyInAnim : public FadeAnim,
+		  virtual public BaseSimAnim,
+          virtual public TransformAnim
+{
+    public:
+	
+	FlyInAnim (CompWindow *w,
+		   WindowEvent curWindowEvent,
+		   float       duration,
+		   const AnimEffect info,
+           const CompRect   &icon) :
+	    Animation::Animation (w, curWindowEvent, duration, info, icon),
+	    BaseSimAnim::BaseSimAnim (w, curWindowEvent, duration, info, icon),
+	    TransformAnim::TransformAnim (w, curWindowEvent, duration, info, icon),
+	    FadeAnim::FadeAnim (w, curWindowEvent, duration, info, icon) {}
+
+    protected:
+	void step () { TransformAnim::step (); }
+	bool updateBBUsed () { return true; }
+	void updateBB (CompOutput &output) {  TransformAnim::updateBB (output); }
+	void applyTransform ();
+	bool requiresTransformedWindow () const { return true; }
+
+	float getFadeProgress ()
+	{
+	    return progressDecelerate (progressLinear ());
+	}
+};
+
+class RotateInAnim: public TransformAnim,
+		    virtual public BaseSimAnim
+{
+    public:
+
+	RotateInAnim (CompWindow *w,
+		      WindowEvent curWindowEvent,
+		      float       duration,
+		      const AnimEffect info,
+		      const CompRect   &icon) :
+	    Animation::Animation (w, curWindowEvent, duration, info, icon),
+	    BaseSimAnim::BaseSimAnim (w, curWindowEvent, duration, info, icon),
+	    TransformAnim::TransformAnim (w, curWindowEvent, duration, info, icon) {}
+
+    protected:
+
+	void step () { TransformAnim::step (); }
+	bool updateBBUsed () { return true; }
+	void updateBB (CompOutput &output) { TransformAnim::updateBB (output); }
+	void applyTransform ();
+	void prePaintWindow ();
+	void postPaintWindow ();
+
+	inline float getProgress ()
+	{
+	    return progressDecelerate (progressLinear ());
+	}
+};
+
+class ExpandAnim: public TransformAnim,
+		  virtual public BaseSimAnim
+{
+    public:
+
+	ExpandAnim (CompWindow *w,
+		    WindowEvent curWindowEvent,
+		    float	duration,
+		    const AnimEffect info,
+		    const CompRect   &icon) :
+		Animation::Animation (w, curWindowEvent, duration, info, icon),
+		BaseSimAnim::BaseSimAnim (w, curWindowEvent, duration, info, icon),
+		TransformAnim::TransformAnim (w, curWindowEvent, duration, info, icon) {}
+
+    protected:
+
+	inline float getProgress ()
+	{
+	    return progressDecelerate (progressLinear ());
+	}
+
+	void applyTransform ();
+    bool updateBBUsed () { return true; }
+	void updateBB (CompOutput &output) { TransformAnim::updateBB (output); }
+};
+
+class ExpandPWAnim: public TransformAnim,
+		    virtual public BaseSimAnim
+{
+    public:
+
+	ExpandPWAnim (CompWindow *w,
+		      WindowEvent curWindowEvent,
+		      float	  duration,
+		      const AnimEffect info,
+		      const CompRect   &icon) :
+		Animation::Animation (w, curWindowEvent, duration, info, icon),
+		BaseSimAnim::BaseSimAnim (w, curWindowEvent, duration, info, icon),
+		TransformAnim::TransformAnim (w, curWindowEvent, duration, info, icon)
+		{
+		}
+
+    protected:
+
+	inline float getProgress ()
+	{
+	    return progressDecelerate (progressLinear ());
+	}
+
+	void applyTransform ();
+	bool updateBBUsed () { return true; }
+	void updateBB (CompOutput &output) { TransformAnim::updateBB (output); }
+};
+
+class BounceAnim: public FadeAnim,
+		  virtual public TransformAnim,
+		  virtual public BaseSimAnim
+{
+    public:
+
+	BounceAnim (CompWindow *w,
+		    WindowEvent curWindowEvent,
+		    float	  duration,
+		    const AnimEffect info,
+		    const CompRect   &icon) :
+	    Animation::Animation (w, curWindowEvent, duration, info, icon),
+	    TransformAnim::TransformAnim (w, curWindowEvent, duration, info, icon),
+	    BaseSimAnim::BaseSimAnim (w, curWindowEvent, duration, info, icon),
+	    FadeAnim::FadeAnim (w, curWindowEvent, duration, info, icon)
+	    {
+		ANIMSIM_SCREEN (screen);
+
+		bounceCount = ass->optionGetBounceNumber ();
+		nBounce = 1;
+		targetScale = ass->optionGetBounceMinSize ();
+		currentScale = ass->optionGetBounceMaxSize ();
+		bounceNeg = false;
+		currBounceProgress = 0.0f;
+		lastProgressMax = 0.0f;
+	    }
+
+    protected:
+
+	void step () { TransformAnim::step (); }
+	void updateBB (CompOutput &output) { TransformAnim::updateBB (output); }
+	bool updateBBUsed () { return true; }
+	bool requiresTransformedWindow () const { return true; }
+
+	void applyTransform ();
+
+	float getProgress ();
+	float getFadeProgress ()
+	{
+	    return progressDecelerate (progressLinear ());
+	}
+
+	int bounceCount;
+	int nBounce;
+	float targetScale;
+	float currentScale;
+	bool  bounceNeg;
+	float currBounceProgress;
+	float lastProgressMax;
+};
+
+class SheetAnim : public GridAnim,
+		  virtual public BaseSimAnim
+{
+    public:
+
+	SheetAnim (CompWindow *w,
+		   WindowEvent curWindowEvent,
+		   float       duration,
+		   const AnimEffect info,
+		   const CompRect   &icon);
+
+	class WaveParam
+	{
+	    public:
+		float halfWidth;
+		float amp;
+		float pos;
+	};
+
+    protected:
+
+	void initGrid ()
+	{
+	    mGridWidth = 30;
+	    mGridHeight = 30;
+	}
+
+	void step ();
+	void updateBB (CompOutput &output);
+	bool updateBBUsed () { return true; }
+	bool stepRegionUsed () { return true; }
+
+	int sheetsWaveCount;
+	std::vector <WaveParam> sheetsWaves;
+};
+
+class PulseSingleAnim : public TransformAnim,
+			virtual public FadeAnim,
+			virtual public BaseSimAnim
+{
+    public:
+
+	PulseSingleAnim (CompWindow *w,
+			 WindowEvent curWindowEvent,
+			 float	  duration,
+			 const      AnimEffect info,
+			 const	  CompRect   &icon) :
+	    Animation::Animation (w, curWindowEvent, duration, info, icon),
+	    FadeAnim::FadeAnim (w, curWindowEvent, duration, info, icon),
+	    BaseSimAnim::BaseSimAnim (w, curWindowEvent, duration, info, icon),
+	    TransformAnim::TransformAnim (w, curWindowEvent, duration, info, icon) {}
+
+	void step () { TransformAnim::step (); }
+	void updateBB (CompOutput &output) { TransformAnim::updateBB (output); }
+	bool updateBBUsed () { return true; }
+	
+	float getProgress () { return progressLinear (); }
+	float getFadeProgress ();
+	
+	void applyTransform ();
+
+    protected:
+
+	bool requiresTransformedWindow () const { return true; }
+};
+
+class PulseAnim : public MultiAnim <PulseSingleAnim, 2>
+{
+    public:
+      
+	PulseAnim (CompWindow *w,
+		   WindowEvent curWindowEvent,
+		   float       duration,
+		   const       AnimEffect info,
+		   const       CompRect &icon) :
+	    MultiAnim <PulseSingleAnim, 2>::MultiAnim
+		  (w, curWindowEvent, duration, info, icon) {}
+		  
+};
+
+class FanSingleAnim : public TransformAnim,
+		      virtual public FadeAnim,
+		      virtual public BaseSimAnim
+{
+    public:
+
+	FanSingleAnim (CompWindow  *w,
+		       WindowEvent curWindowEvent,
+		       float	   duration,
+		       const	   AnimEffect info,
+		       const	   CompRect   &icon) :
+	    Animation::Animation (w, curWindowEvent, duration, info, icon),
+	    FadeAnim::FadeAnim (w, curWindowEvent, duration, info, icon),
+	    BaseSimAnim::BaseSimAnim (w, curWindowEvent, duration, info, icon),
+	    TransformAnim::TransformAnim (w, curWindowEvent, duration, info, icon) {}
+
+	void step () { TransformAnim::step (); }
+	void updateBB (CompOutput &output) { TransformAnim::updateBB (output); }
+	bool updateBBUsed () { return true; }
+	
+	float getProgress () { return progressLinear (); }
+	float getFadeProgress ();
+	
+	void applyTransform ();
+
+    protected:
+
+	bool requiresTransformedWindow () const { return true; }
+};
+
+class FanAnim : public MultiAnim <FanSingleAnim, 6>
+{
+    public:
+
+	FanAnim (CompWindow *w,
+		 WindowEvent curWindowEvent,
+		 float       duration,
+		 const       AnimEffect info,
+		 const       CompRect &icon) :
+	    MultiAnim <FanSingleAnim, 6>::MultiAnim
+	    (w, curWindowEvent, duration, info, icon) {}
+};
+
+class AnimSimPluginVTable:
+	public CompPlugin::VTableForScreenAndWindow <AnimSimScreen, AnimSimWindow>
+{
+    public:
+	bool init ();
+};
diff -Npur compiz-0.9.13.0.orig/plugins/simple-animations/src/bounce.cpp compiz-0.9.13.0/plugins/simple-animations/src/bounce.cpp
--- compiz-0.9.13.0.orig/plugins/simple-animations/src/bounce.cpp	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/simple-animations/src/bounce.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,76 @@
+/*
+ * Animation plugin for compiz/beryl
+ *
+ * animation.c
+ *
+ * Copyright : (C) 2006 Erkin Bahceci
+ * E-mail    : erkinbah@gmail.com
+ *
+ * Based on Wobbly and Minimize plugins by
+ *           : David Reveman
+ * E-mail    : davidr@novell.com>
+ *
+ * Particle system added by : (C) 2006 Dennis Kasprzyk
+ * E-mail                   : onestone@beryl-project.org
+ *
+ * Beam-Up added by : Florencio Guimaraes
+ * E-mail           : florencio@nexcorp.com.br
+ *
+ * Hexagon tessellator added by : Mike Slegeir
+ * E-mail                       : mikeslegeir@mail.utexas.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include "animationsim.h"
+
+// =====================  Effect: Bounce  =========================
+
+float
+BounceAnim::getProgress ()
+{
+    return progressLinear ();
+}
+
+void
+BounceAnim::applyTransform ()
+{
+    float scale = 1.0f - (targetScale * (currBounceProgress) + currentScale * (1.0f - currBounceProgress));
+    float forwardProgress = getProgress ();;
+    float forwardProgressInc = 1.0f / bounceCount;
+
+    /* last bounce, enure we are going for 0.0 */
+    currBounceProgress = (((1 - forwardProgress) - lastProgressMax) / forwardProgressInc);
+
+    if (currBounceProgress > 1.0f)
+    {
+	currentScale = targetScale;
+	targetScale = -targetScale + targetScale / 2.0f;
+	lastProgressMax = 1.0f - forwardProgress;
+	currBounceProgress = 0.0f;
+	nBounce++;
+    }
+
+    GLMatrix *transform = &mTransform;
+
+    transform->translate (WIN_X (mWindow) + WIN_W (mWindow) / 2.0f,
+			  WIN_Y (mWindow) + WIN_H (mWindow) / 2.0f, 0.0f);
+
+    transform->scale (scale, scale, 1.0f);
+
+    transform->translate (-(WIN_X (mWindow) + WIN_W (mWindow) / 2.0f),
+			  -(WIN_Y (mWindow) + WIN_H (mWindow) / 2.0f), 0.0f);
+
+}
diff -Npur compiz-0.9.13.0.orig/plugins/simple-animations/src/expand.cpp compiz-0.9.13.0/plugins/simple-animations/src/expand.cpp
--- compiz-0.9.13.0.orig/plugins/simple-animations/src/expand.cpp	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/simple-animations/src/expand.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,70 @@
+/*
+ * Animation plugin for compiz/beryl
+ *
+ * animation.c
+ *
+ * Copyright : (C) 2006 Erkin Bahceci
+ * E-mail    : erkinbah@gmail.com
+ *
+ * Based on Wobbly and Minimize plugins by
+ *           : David Reveman
+ * E-mail    : davidr@novell.com>
+ *
+ * Particle system added by : (C) 2006 Dennis Kasprzyk
+ * E-mail                   : onestone@beryl-project.org
+ *
+ * Beam-Up added by : Florencio Guimaraes
+ * E-mail           : florencio@nexcorp.com.br
+ *
+ * Hexagon tessellator added by : Mike Slegeir
+ * E-mail                       : mikeslegeir@mail.utexas.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include "animationsim.h"
+
+// =====================  Effect: Expand  =========================
+
+void
+ExpandAnim::applyTransform ()
+{
+    GLMatrix *transform = &mTransform;
+    float defaultXScale = 0.3f;
+    float forwardProgress;
+    float expandProgress;
+    const float expandPhaseEnd = 0.5f;
+
+    forwardProgress = getProgress ();
+
+    if ((1 - forwardProgress) < expandPhaseEnd)
+	expandProgress = (1 - forwardProgress) / expandPhaseEnd;
+    else
+	expandProgress = 1.0f;
+
+    // animation movement
+    transform->translate (WIN_X (mWindow) + WIN_W (mWindow) / 2.0f,
+			  WIN_Y (mWindow) + WIN_H (mWindow) / 2.0f,
+			  0.0f); 
+
+    transform->scale (defaultXScale + (1.0f - defaultXScale) *
+		      expandProgress,
+		      (1 - forwardProgress), 0.0f);
+
+    transform->translate (-(WIN_X (mWindow) + WIN_W (mWindow) / 2.0f),
+		      	  -(WIN_Y (mWindow) + WIN_H (mWindow) / 2.0f),
+		      	  0.0f);
+
+}
diff -Npur compiz-0.9.13.0.orig/plugins/simple-animations/src/expand-piecewise.cpp compiz-0.9.13.0/plugins/simple-animations/src/expand-piecewise.cpp
--- compiz-0.9.13.0.orig/plugins/simple-animations/src/expand-piecewise.cpp	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/simple-animations/src/expand-piecewise.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,90 @@
+/*
+ * Animation plugin for compiz/beryl
+ *
+ * animation.c
+ *
+ * Copyright : (C) 2006 Erkin Bahceci
+ * E-mail    : erkinbah@gmail.com
+ *
+ * Based on Wobbly and Minimize plugins by
+ *           : David Reveman
+ * E-mail    : davidr@novell.com>
+ *
+ * Particle system added by : (C) 2006 Dennis Kasprzyk
+ * E-mail                   : onestone@beryl-project.org
+ *
+ * Beam-Up added by : Florencio Guimaraes
+ * E-mail           : florencio@nexcorp.com.br
+ *
+ * Hexagon tessellator added by : Mike Slegeir
+ * E-mail                       : mikeslegeir@mail.utexas.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include "animationsim.h"
+#define DELTA 0.0001f
+
+// =====================  Effect: ExpandPW  =========================
+
+void
+ExpandPWAnim::applyTransform ()
+{
+    ANIMSIM_SCREEN (screen);
+
+    GLMatrix *transform = &mTransform;
+
+    float forwardProgress = 1.0f - getProgress ();
+
+    float initialXScale = ass->optionGetExpandpwInitialHoriz () / (float) mWindow->width ();
+    float initialYScale = ass->optionGetExpandpwInitialVert ()  / (float) mWindow->height ();
+
+    // animation movement
+    transform->translate (WIN_X (mWindow) + WIN_W (mWindow) / 2.0f,
+			  WIN_Y (mWindow) + WIN_H (mWindow) / 2.0f,
+			  0.0f);
+
+    float xScale;
+    float yScale;
+    float switchPointP;
+    float switchPointN;
+    float delay = ass->optionGetExpandpwDelay ();
+
+    if (ass->optionGetExpandpwHorizFirst ())
+    {
+        switchPointP = mWindow->width () / (float) (mWindow->width () + mWindow->height ()) + mWindow->height () / (float) (mWindow->width () + mWindow->height ()) * delay;
+        switchPointN = mWindow->width () / (float) (mWindow->width () + mWindow->height ()) - mWindow->width () / (float) (mWindow->width () + mWindow->height ()) * delay;
+        if(switchPointP >= 1.0f) switchPointP = 1.0f - DELTA;
+        if(switchPointN <= 0.0f) switchPointN = 0.0f + DELTA;
+        xScale = initialXScale + (1.0f - initialXScale) * (forwardProgress < switchPointN ? 1.0f - (switchPointN - forwardProgress)/switchPointN : 1.0f);
+        yScale = initialYScale + (1.0f - initialYScale) * (forwardProgress > switchPointP ? (forwardProgress - switchPointP)/(1.0f-switchPointP) : 0.0f);
+    }
+    else
+    {
+        switchPointP = mWindow->height () / (float) (mWindow->width () + mWindow->height ()) + mWindow->width () / (float) (mWindow->width () + mWindow->height ()) * delay;
+        switchPointN = mWindow->height () / (float) (mWindow->width () + mWindow->height ()) - mWindow->height () / (float) (mWindow->width () + mWindow->height ()) * delay;
+        if(switchPointP >= 1.0f) switchPointP = 1.0f - DELTA;
+        if(switchPointN <= 0.0f) switchPointN = 0.0f + DELTA;
+        xScale = initialXScale + (1.0f - initialXScale) * (forwardProgress > switchPointP ? (forwardProgress - switchPointP)/(1.0f-switchPointP) : 0.0f);
+        yScale = initialYScale + (1.0f - initialYScale) * (forwardProgress < switchPointN ? 1.0f - (switchPointN - forwardProgress)/switchPointN : 1.0f);
+    }
+
+    transform->scale (xScale, yScale, 0.0f);
+
+    transform->translate (-(WIN_X (mWindow) + WIN_W (mWindow) / 2.0f),
+			  -(WIN_Y (mWindow) + WIN_H (mWindow) / 2.0f),
+			  0.0f);
+
+}
diff -Npur compiz-0.9.13.0.orig/plugins/simple-animations/src/fan.cpp compiz-0.9.13.0/plugins/simple-animations/src/fan.cpp
--- compiz-0.9.13.0.orig/plugins/simple-animations/src/fan.cpp	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/simple-animations/src/fan.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,51 @@
+#include "animationsim.h"
+
+float
+FanSingleAnim::getFadeProgress ()
+{
+    return getProgress ();
+};
+
+void
+FanSingleAnim::applyTransform ()
+{
+    /* Starting angle is as a percentage of whichever fan number we are
+     * closest to the center
+     */
+    
+    ANIMSIM_SCREEN (screen);
+    
+    int num = MultiAnim <FanSingleAnim, 6>::getCurrAnimNumber (mAWindow);
+    
+    if (num > 2)
+	num += 1;
+    
+    float div = (ass->optionGetFanAngle () * 2) / 6;
+    float startAng = -(ass->optionGetFanAngle ()) + (div * num);
+    float currAng = getProgress () * startAng;
+    float offset = (1 - getProgress ()) * (WIN_H (mWindow) / 2);
+    
+    if (num > 3)
+	num += 1;
+    
+    if (num > 3)
+    {
+	mTransform.translate (WIN_X (mWindow) + WIN_W (mWindow) - offset,
+			      WIN_Y (mWindow) + WIN_H (mWindow),
+			      0.0f);
+	mTransform.rotate (currAng, 0.0f, 0.0f, 1.0f);
+	mTransform.translate (-(WIN_X (mWindow) + WIN_W (mWindow) - offset),
+			      -(WIN_Y (mWindow) + WIN_H (mWindow)),
+			      0.0f);
+    }
+    else
+    {
+	mTransform.translate (WIN_X (mWindow) + offset,
+			      WIN_Y (mWindow) + WIN_H (mWindow),
+			      0.0f);
+	mTransform.rotate (currAng, 0.0f, 0.0f, 1.0f);
+	mTransform.translate (-(WIN_X (mWindow) + offset),
+			      -(WIN_Y (mWindow) + WIN_H (mWindow)),
+			      0.0f);
+    }
+}
diff -Npur compiz-0.9.13.0.orig/plugins/simple-animations/src/flyin.cpp compiz-0.9.13.0/plugins/simple-animations/src/flyin.cpp
--- compiz-0.9.13.0.orig/plugins/simple-animations/src/flyin.cpp	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/simple-animations/src/flyin.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,86 @@
+/*
+ * Animation plugin for compiz/beryl
+ *
+ * animation.c
+ *
+ * Copyright : (C) 2006 Erkin Bahceci
+ * E-mail    : erkinbah@gmail.com
+ *
+ * Based on Wobbly and Minimize plugins by
+ *           : David Reveman
+ * E-mail    : davidr@novell.com>
+ *
+ * Particle system added by : (C) 2006 Dennis Kasprzyk
+ * E-mail                   : onestone@beryl-project.org
+ *
+ * Beam-Up added by : Florencio Guimaraes
+ * E-mail           : florencio@nexcorp.com.br
+ *
+ * Hexagon tessellator added by : Mike Slegeir
+ * E-mail                       : mikeslegeir@mail.utexas.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include "animationsim.h"
+
+// =====================  Effect: Flyin  =========================
+
+void
+FlyInAnim::applyTransform ()
+{
+    GLMatrix *transform = &mTransform;
+    float offsetX = 0, offsetY = 0;
+    float xTrans, yTrans;
+    float forwardProgress;
+
+    ANIMSIM_SCREEN (screen);
+
+    int direction = ass->optionGetFlyinDirection ();
+    float distance = ass->optionGetFlyinDistance ();
+
+    switch (direction)
+    {
+	case 0:
+	    offsetX = 0;	 
+	    offsetY = distance;
+	    break;
+	case 1:
+	    offsetX = distance;
+	    offsetY = 0;
+	    break;
+	case 2:
+	    offsetX = 0;
+	    offsetY = -distance;
+	    break;
+	case 3:
+	    offsetX = -distance;
+	    offsetY = 0;
+	    break;
+	case 4:
+	    offsetX = ass->optionGetFlyinDirectionX ();
+	    offsetY = ass->optionGetFlyinDirectionY ();
+	    break;
+    }
+
+    forwardProgress = progressLinear ();
+    xTrans = -(forwardProgress * offsetX);
+    yTrans = -(forwardProgress * offsetY);
+    Point3d translation = Point3d (xTrans, yTrans, 0);
+
+    // animation movement
+    transform->translate (translation.x (), translation.y (), translation.z ());
+
+}
diff -Npur compiz-0.9.13.0.orig/plugins/simple-animations/src/pulse.cpp compiz-0.9.13.0/plugins/simple-animations/src/pulse.cpp
--- compiz-0.9.13.0.orig/plugins/simple-animations/src/pulse.cpp	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/simple-animations/src/pulse.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,50 @@
+#include "animationsim.h"
+
+/* Keep the "principal" window at 100% opacity, only fade out
+ * the window that is "pulsing" away
+ */
+
+float
+PulseSingleAnim::getFadeProgress ()
+{
+    int num = MultiAnim <PulseSingleAnim, 2>::getCurrAnimNumber (mAWindow);
+    
+    if (num == 1)
+	return 1 - getProgress ();
+    else
+	return 0.0f;
+};
+
+void
+PulseSingleAnim::applyTransform ()
+{
+    float scale = 1.0f + (1- getProgress ());
+    
+    /* Add a bit of a "kick" for open, close,
+     * minimize, unminimize, etc anims */
+    
+    switch (mCurWindowEvent)
+    {
+	case WindowEventOpen:
+	case WindowEventClose:
+	case WindowEventMinimize:
+	case WindowEventUnminimize:
+	    scale -= 0.2f;
+	default:
+	    break;
+    }
+    
+    if (MultiAnim <PulseSingleAnim, 2>::getCurrAnimNumber (mAWindow) == 0)
+	if (scale > 1.0f)
+	    scale = 1.0f;
+  
+    GLMatrix *transform = &mTransform;
+
+    transform->translate (WIN_X (mWindow) + WIN_W (mWindow) / 2.0f,
+			  WIN_Y (mWindow) + WIN_H (mWindow) / 2.0f, 0.0f);
+
+    transform->scale (scale, scale, 1.0f);
+
+    transform->translate (-(WIN_X (mWindow) + WIN_W (mWindow) / 2.0f),
+			  -(WIN_Y (mWindow) + WIN_H (mWindow) / 2.0f), 0.0f);
+}
\ Kein Zeilenumbruch am Dateiende.
diff -Npur compiz-0.9.13.0.orig/plugins/simple-animations/src/rotatein.cpp compiz-0.9.13.0/plugins/simple-animations/src/rotatein.cpp
--- compiz-0.9.13.0.orig/plugins/simple-animations/src/rotatein.cpp	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/simple-animations/src/rotatein.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,210 @@
+/*
+ * Animation plugin for compiz/beryl
+ *
+ * animation.c
+ *
+ * Copyright : (C) 2006 Erkin Bahceci
+ * E-mail    : erkinbah@gmail.com
+ *
+ * Based on Wobbly and Minimize plugins by
+ *           : David Reveman
+ * E-mail    : davidr@novell.com>
+ *
+ * Particle system added by : (C) 2006 Dennis Kasprzyk
+ * E-mail                   : onestone@beryl-project.org
+ *
+ * Beam-Up added by : Florencio Guimaraes
+ * E-mail           : florencio@nexcorp.com.br
+ *
+ * Hexagon tessellator added by : Mike Slegeir
+ * E-mail                       : mikeslegeir@mail.utexas.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include "animationsim.h"
+
+// =====================  Effect: RotateIn  =========================
+
+void
+RotateInAnim::applyTransform ()
+{
+    ANIMSIM_SCREEN (screen);
+
+    GLMatrix *transform = &mTransform;
+    float xRot, yRot;
+    float angleX = 0, angleY = 0;
+    float originX = 0, originY = 0;
+    float forwardProgress;
+
+    int direction = ass->optionGetRotateinDirection ();
+
+    switch (direction)
+    {
+	case 1:
+	    angleX = 0;
+	    angleY = -ass->optionGetRotateinAngle ();
+	    originX = WIN_X (mWindow);
+	    originY = WIN_Y (mWindow) + WIN_H (mWindow);
+	    break;
+	case 2:
+	    angleX = ass->optionGetRotateinAngle ();
+	    angleY = 0;
+	    originX = WIN_X (mWindow);
+	    originY = WIN_Y (mWindow);
+	    break;
+	case 3:
+	    angleX = 0;
+	    angleY = ass->optionGetRotateinAngle ();
+	    originX = WIN_X (mWindow);
+	    originY = WIN_Y (mWindow);
+	    break;
+	case 4:
+	    angleX = -ass->optionGetRotateinAngle ();
+	    angleY = 0;
+	    originX = WIN_X (mWindow) + WIN_W (mWindow);
+	    originY = WIN_Y (mWindow);
+	    break;
+    }
+
+    forwardProgress = getProgress ();
+    xRot = (forwardProgress * angleX);
+    yRot = (forwardProgress * angleY);
+
+    transform->translate (WIN_X (mWindow) + WIN_W (mWindow) / 2.0f,
+			  WIN_Y (mWindow) + WIN_H (mWindow) / 2.0f,
+			  0.0f);
+
+    perspectiveDistortAndResetZ (*transform);
+
+    transform->translate (-(WIN_X (mWindow) + WIN_W (mWindow) / 2.0f),
+			  -(WIN_Y (mWindow) + WIN_H (mWindow) / 2.0f),
+			  0.0f);
+
+    // animation movement
+    transform->translate (originX, originY, 0.0f);
+
+    transform->rotate (yRot, 1.0f, 0.0f, 0.0f);
+    transform->rotate (xRot, 0.0f, 1.0f, 0.0f);
+
+    transform->translate (-originX, -originY, 0.0f);
+
+}
+
+void 
+RotateInAnim::prePaintWindow ()
+{
+    float forwardProgress = getProgress ();
+    float xRot, yRot;
+    float angleX = 0, angleY = 0;
+    Bool  xInvert = FALSE, yInvert = FALSE;
+    int currentCull, invertCull;
+
+    glGetIntegerv (GL_CULL_FACE_MODE, &currentCull);
+    invertCull = (currentCull == GL_BACK) ? GL_FRONT : GL_BACK;
+
+    ANIMSIM_SCREEN (screen);
+
+    int direction = ass->optionGetRotateinDirection ();
+
+    switch (direction)
+    {
+	case 1:
+	    angleX = 0;
+	    angleY = -ass->optionGetRotateinAngle ();
+	    break;
+	case 2:
+	    angleX = ass->optionGetRotateinAngle ();
+	    angleY = 0;
+	    break;
+	case 3:
+	    angleX = 0;
+	    angleY = ass->optionGetRotateinAngle ();
+	    break;
+	case 4:
+	    angleX = -ass->optionGetRotateinAngle ();
+	    angleY = 0;
+	    break;
+    }
+
+    /* FIXME: This could be fancy vectorial normal direction calculation */
+
+    xRot = fabs(fmodf(forwardProgress * angleX, 360.0f));
+    yRot = fabs(fmodf(forwardProgress * angleY, 360.0f));
+
+    if (xRot > 270.0f)
+	xInvert = TRUE;
+
+    if (yRot > 270.0f)
+	yInvert = TRUE;
+
+    if ((xInvert || yInvert) && !(xInvert && yInvert))
+	glCullFace (invertCull);
+}
+
+void
+RotateInAnim::postPaintWindow ()
+{
+    float forwardProgress = getProgress ();
+    float xRot, yRot;
+    float angleX = 0, angleY = 0;
+    Bool  xInvert = FALSE, yInvert = FALSE;
+    int currentCull, invertCull;
+
+    glGetIntegerv (GL_CULL_FACE_MODE, &currentCull);
+    invertCull = (currentCull == GL_BACK) ? GL_FRONT : GL_BACK;
+
+    ANIMSIM_SCREEN (screen);
+
+    int direction = ass->optionGetRotateinDirection ();
+
+    switch (direction)
+    {
+	case 1:
+	    angleX = 0;
+	    angleY = -ass->optionGetRotateinAngle ();
+	    break;
+	case 2:
+	    angleX = ass->optionGetRotateinAngle ();
+	    angleY = 0;
+	    break;
+	case 3:
+	    angleX = 0;
+	    angleY = ass->optionGetRotateinAngle ();
+	    break;
+	case 4:
+	    angleX = -ass->optionGetRotateinAngle ();
+	    angleY = 0;
+	    break;
+    }
+
+    /* FIXME: This could be fancy vectorial normal direction calculation */
+
+    xRot = fabs(fmodf(forwardProgress * angleX, 360.0f));
+    yRot = fabs(fmodf(forwardProgress * angleY, 360.0f));
+
+    if (xRot > 270.0f)
+	xInvert = TRUE;
+
+    if (yRot > 270.0f)
+	yInvert = TRUE;
+
+    /* We have to assume that invertCull will be
+     * the actual inversion of our previous cull
+     */
+
+    if ((xInvert || yInvert) && !(xInvert && yInvert))
+	glCullFace (invertCull);
+}
diff -Npur compiz-0.9.13.0.orig/plugins/simple-animations/src/sheet.cpp compiz-0.9.13.0/plugins/simple-animations/src/sheet.cpp
--- compiz-0.9.13.0.orig/plugins/simple-animations/src/sheet.cpp	1970-01-01 01:00:00.000000000 +0100
+++ compiz-0.9.13.0/plugins/simple-animations/src/sheet.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -0,0 +1,275 @@
+/*
+ * Animation plugin for compiz/beryl
+ *
+ * animation.c
+ *
+ * Copyright : (C) 2006 Erkin Bahceci
+ * E-mail    : erkinbah@gmail.com
+ *
+ * Based on Wobbly and Minimize plugins by
+ *           : David Reveman
+ * E-mail    : davidr@novell.com>
+ *
+ * Particle system added by : (C) 2006 Dennis Kasprzyk
+ * E-mail                   : onestone@beryl-project.org
+ *
+ * Beam-Up added by : Florencio Guimaraes
+ * E-mail           : florencio@nexcorp.com.br
+ *
+ * Hexagon tessellator added by : Mike Slegeir
+ * E-mail                       : mikeslegeir@mail.utexas.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include "animationsim.h"
+
+SheetAnim::SheetAnim (CompWindow *w,
+		      WindowEvent curWindowEvent,
+		      float       duration,
+		      const AnimEffect info,
+		      const CompRect   &minIcon) :
+    Animation::Animation (w, curWindowEvent, duration, info, minIcon),
+    BaseSimAnim::BaseSimAnim (w, curWindowEvent, duration, info, minIcon),
+    GridAnim::GridAnim (w, curWindowEvent, duration, info, minIcon)
+{
+    int maxWaves;
+    float waveAmpMin, waveAmpMax;
+    CompWindow *parent = 0;
+    CompRect   icon = minIcon;
+
+    foreach (parent, screen->windows ())
+    {
+	if (parent->transientFor () == w->id () && parent->id () != w->id ())
+	    break;
+    }
+
+    if (parent)
+    {
+	icon.setX (WIN_X (parent) + WIN_W (parent) / 2.0f);
+	icon.setY (WIN_Y (parent));
+	icon.setWidth (WIN_W (w));
+    }
+    else
+    {
+	icon.setX (screen->width () / 2.0f);
+	icon.setY (0.0f);;
+	icon.setWidth (WIN_W (w));
+    }
+
+    maxWaves = 0;
+    waveAmpMin = 0.0f;
+    waveAmpMax = 0.0f;
+
+    if (maxWaves == 0)
+    {
+	sheetsWaveCount = 0;
+    }
+    else
+    {
+	// Initialize waves
+
+	float distance = WIN_Y(w) + WIN_H(w) - icon.y ();
+
+	sheetsWaveCount =
+	1 + (float)maxWaves *distance;
+
+	if (sheetsWaves.empty ())
+	{
+	    sheetsWaves.resize (sheetsWaveCount);
+	}
+	// Compute wave parameters
+
+	int ampDirection = (RAND_FLOAT() < 0.5 ? 1 : -1);
+	float minHalfWidth = 0.22f;
+	float maxHalfWidth = 0.38f;
+
+	for (unsigned int i = 0; i < sheetsWaves.size (); i++)
+	{
+	    sheetsWaves[i].amp =
+		ampDirection * (waveAmpMax - waveAmpMin) *
+		rand() / RAND_MAX + ampDirection * waveAmpMin;
+	    sheetsWaves[i].halfWidth =
+		RAND_FLOAT() * (maxHalfWidth -
+				minHalfWidth) + minHalfWidth;
+
+	    // avoid offset at top and bottom part by added waves
+	    float availPos = 1 - 2 * sheetsWaves[i].halfWidth;
+	    float posInAvailSegment = 0;
+
+	    if (i > 0)
+	        posInAvailSegment =
+		    (availPos / sheetsWaveCount) * rand() / RAND_MAX;
+
+	    sheetsWaves[i].pos =
+	        (posInAvailSegment +
+	         i * availPos / sheetsWaveCount +
+	         sheetsWaves[i].halfWidth);
+
+	    // switch wave direction
+	    ampDirection *= -1;
+	}
+    }
+}
+
+void
+SheetAnim::updateBB (CompOutput &output)
+{
+    // TODO: Just consider the corner objects
+
+    CompositeScreen::get (screen)->damageScreen (); // XXX: *COUGH!!!!*
+}
+
+void
+SheetAnim::step ()
+{
+    GridModel *model = mModel;
+    CompRect &icon = mIcon;
+    CompWindow *parent = 0;
+
+    foreach (parent, screen->windows ())
+    {
+	if (parent->transientFor () == mWindow->id () && parent->id () != mWindow->id ())
+	    break;
+    }
+
+    if (parent)
+    {
+	icon.setX (WIN_X (parent) + WIN_W (parent) / 2.0f);
+	icon.setY (WIN_Y (parent));
+	icon.setWidth (WIN_W (mWindow));
+    }
+    else
+    {
+	icon.setX (screen->width () / 2.0f);
+	icon.setY (0.0f);;
+	icon.setWidth (WIN_W (mWindow));
+    }
+
+    float forwardProgress = progressLinear ();
+
+    if (sheetsWaveCount > 0 && sheetsWaves.empty ())
+	return;
+
+    float iconCloseEndY;
+    float iconFarEndY;
+    float winFarEndY;
+    float winVisibleCloseEndY;
+    float winw = WIN_W(mWindow);
+    float winh = WIN_H(mWindow);
+
+
+    iconFarEndY = icon.y ();
+    iconCloseEndY = icon.y () + icon.height ();
+    winFarEndY = WIN_Y(mWindow) + winh;
+    winVisibleCloseEndY = WIN_Y(mWindow);
+    if (winVisibleCloseEndY < iconCloseEndY)
+	winVisibleCloseEndY = iconCloseEndY;
+
+
+    float preShapePhaseEnd = 0.22f;
+    float preShapeProgress  = 0;
+    float postStretchProgress = 0;
+    float stretchProgress = 0;
+    float stretchPhaseEnd =
+	preShapePhaseEnd + (1 - preShapePhaseEnd) *
+	(iconCloseEndY -
+	 winVisibleCloseEndY) / ((iconCloseEndY - winFarEndY) +
+				 (iconCloseEndY - winVisibleCloseEndY));
+    if (stretchPhaseEnd < preShapePhaseEnd + 0.1)
+	stretchPhaseEnd = preShapePhaseEnd + 0.1;
+
+    if (forwardProgress < preShapePhaseEnd)
+    {
+	preShapeProgress = forwardProgress / preShapePhaseEnd;
+
+	// Slow down "shaping" toward the end
+	preShapeProgress = 1 - progressDecelerate (1 - preShapeProgress);
+    }
+
+    if (forwardProgress < preShapePhaseEnd)
+    {
+	stretchProgress = forwardProgress / stretchPhaseEnd;
+    }
+    else
+    {
+	if (forwardProgress < stretchPhaseEnd)
+	{
+	    stretchProgress = forwardProgress / stretchPhaseEnd;
+	}
+	else
+	{
+	    postStretchProgress =
+		(forwardProgress - stretchPhaseEnd) / (1 - stretchPhaseEnd);
+	}
+    }
+
+    GridModel::GridObject *object = mModel->objects ();
+    unsigned int i;
+    for (i = 0; i < mModel->numObjects (); i++, object++)
+    {
+	float origx = mWindow->x () + (winw * object->gridPosition ().x () -
+				     mWindow->output ().left) * model->scale ().x ();
+	float origy = mWindow->y () + (winh * object->gridPosition ().y () -
+				     mWindow->output ().top) * model->scale ().y ();
+	float icony = icon.y () + icon.height ();
+
+	float stretchedPos;
+	Point3d &objPos = object->position ();
+	stretchedPos =
+		object->gridPosition ().y () * origy +
+		(1 - object->gridPosition ().y ()) * icony;
+
+	// Compute current y position
+	if (forwardProgress < preShapePhaseEnd)
+	{
+	    objPos.setY ((1 - stretchProgress) * origy +
+		stretchProgress * stretchedPos);
+	}
+	else
+	{
+	    if (forwardProgress < stretchPhaseEnd)
+	    {
+		objPos.setY ((1 - stretchProgress) * origy +
+		    stretchProgress * stretchedPos);
+	    }
+	    else
+	    {
+		objPos.setY ((1 - postStretchProgress) *
+		    stretchedPos +
+		    postStretchProgress *
+		    (stretchedPos + (iconCloseEndY - winFarEndY)));
+	    }
+	}
+
+	// Compute "target shape" x position
+	float yProgress = (iconCloseEndY - object->position ().y () ) / (iconCloseEndY - winFarEndY);
+
+	float targetx = yProgress * (origx - icon.x ())
+	 + icon.x () + icon.width () * (object->gridPosition ().x () - 0.5);
+
+	// Compute current x position
+	if (forwardProgress < preShapePhaseEnd)
+	    objPos.setX ((1 - preShapeProgress) * origx + preShapeProgress * targetx);
+	else
+	    objPos.setX (targetx);
+
+	if (object->position ().y () < iconFarEndY)
+	    objPos.setY (iconFarEndY);
+
+	// No need to set object->position.z to 0, since they won't be used
+	// due to modelAnimIs3D being FALSE for magic lamp.
+    }
+}
diff -Npur compiz-0.9.13.0.orig/plugins/switcher/src/switcher.cpp compiz-0.9.13.0/plugins/switcher/src/switcher.cpp
--- compiz-0.9.13.0.orig/plugins/switcher/src/switcher.cpp	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/plugins/switcher/src/switcher.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -20,7 +20,9 @@
  * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
  * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  *
- * Author: David Reveman <davidr@novell.com>
+ * Author(s):
+ *  - David Reveman <davidr@novell.com>
+ *  - Auboyneau Vincent <ksamak@riseup.net> (size multiplier for A11Y)
  */
 
 #include "switcher.h"
@@ -35,36 +37,6 @@ const unsigned short BOX_WIDTH = 3;
 
 #define XWINDOWCHANGES_INIT {0, 0, 0, 0, 0, None, 0}
 
-static float _boxVertices[] =
-{
-    -(WIDTH >> 1), BOX_WIDTH, 0.0f,
-     (WIDTH >> 1), BOX_WIDTH, 0.0f,
-    -(WIDTH >> 1), 0.0f,      0.0f,
-    -(WIDTH >> 1), 0.0f,      0.0f,
-     (WIDTH >> 1), BOX_WIDTH, 0.0f,
-     (WIDTH >> 1), 0.0f,      0.0f,
-
-    -(WIDTH >> 1),             HEIGHT - BOX_WIDTH, 0.0f,
-    -(WIDTH >> 1) + BOX_WIDTH, HEIGHT - BOX_WIDTH, 0.0f,
-    -(WIDTH >> 1),             BOX_WIDTH,          0.0f,
-    -(WIDTH >> 1),             BOX_WIDTH,          0.0f,
-    -(WIDTH >> 1) + BOX_WIDTH, HEIGHT - BOX_WIDTH, 0.0f,
-    -(WIDTH >> 1) + BOX_WIDTH, BOX_WIDTH,          0.0f,
-
-     (WIDTH >> 1) - BOX_WIDTH, HEIGHT - BOX_WIDTH, 0.0f,
-     (WIDTH >> 1),             HEIGHT - BOX_WIDTH, 0.0f,
-     (WIDTH >> 1) - BOX_WIDTH, BOX_WIDTH,          0.0f,
-     (WIDTH >> 1) - BOX_WIDTH, BOX_WIDTH,          0.0f,
-     (WIDTH >> 1),             HEIGHT - BOX_WIDTH, 0.0f,
-     (WIDTH >> 1),             BOX_WIDTH,          0.0f,
-
-    -(WIDTH >> 1), HEIGHT,             0.0f,
-     (WIDTH >> 1), HEIGHT,             0.0f,
-    -(WIDTH >> 1), HEIGHT - BOX_WIDTH, 0.0f,
-    -(WIDTH >> 1), HEIGHT - BOX_WIDTH, 0.0f,
-     (WIDTH >> 1), HEIGHT,             0.0f,
-     (WIDTH >> 1), HEIGHT - BOX_WIDTH, 0.0f,
-};
 
 void
 SwitchScreen::updateWindowList (int count)
@@ -78,7 +50,7 @@ SwitchScreen::updateWindowList (int coun
 	    count = 3;
     }
 
-    pos  = ((count >> 1) - (int)windows.size ()) * WIDTH;
+    pos  = ((count >> 1) - (int)windows.size ()) * modifiedWidth;
     move = 0;
 
     selectedWindow = windows.front ();
@@ -184,9 +156,9 @@ void
 SwitchScreen::handleSelectionChange (bool toNext, int nextIdx)
 {
     if (toNext)
-	move -= WIDTH;
+	move -= modifiedWidth;
     else
-	move += WIDTH;
+	move += modifiedWidth;
 
     moreAdjust = true;
 }
@@ -532,7 +504,7 @@ SwitchScreen::windowRemove (CompWindow *
 
 	updateWindowList (count);
 
-	allWindowsWidth = windows.size () * WIDTH;
+	allWindowsWidth = windows.size () * modifiedWidth;
 
 	foreach (CompWindow *win, windows)
 	{
@@ -541,7 +513,7 @@ SwitchScreen::windowRemove (CompWindow *
 	    if (selectedWindow == selected)
 		break;
 
-	    pos -= WIDTH;
+	    pos -= modifiedWidth;
 	    if (pos < -allWindowsWidth)
 		pos += allWindowsWidth;
 	}
@@ -650,7 +622,7 @@ SwitchScreen::preparePaint (int msSinceL
 	float amount, chunk;
 	int   allWindowsWidth;
 
-	allWindowsWidth = windows.size () * WIDTH;
+	allWindowsWidth = windows.size () * modifiedWidth;
 
 	amount = msSinceLastPaint * 0.05f * optionGetSpeed ();
 	steps  = amount / (0.5f * optionGetTimestep ());
@@ -878,10 +850,10 @@ SwitchWindow::paintThumb (const GLWindow
     				  mask,
     				  x,
     				  y,
-    				  WIDTH  - (SPACE << 1),
-    				  HEIGHT - (SPACE << 1),
-    				  WIDTH  - (WIDTH  >> 2),
-    				  HEIGHT - (HEIGHT >> 2));
+    				  sScreen->modifiedWidth  - (SPACE << 1),
+    				  sScreen->modifiedHeight - (SPACE << 1),
+    				  sScreen->modifiedWidth  - (sScreen->modifiedWidth  >> 2),
+    				  sScreen->modifiedHeight - (sScreen->modifiedHeight >> 2));
 }
 
 void
@@ -901,8 +873,8 @@ SwitchWindow::updateIconTexturedWindow (
     else
 	sAttrib.xScale = sAttrib.yScale;
 
-    wx = x + WIDTH  - icon->width ()  * sAttrib.xScale - SPACE;
-    wy = y + HEIGHT - icon->height () * sAttrib.yScale - SPACE;
+    wx = x + sScreen->modifiedWidth - icon->width ()  * sAttrib.xScale - SPACE;
+    wy = y + sScreen->modifiedWidth - icon->height () * sAttrib.yScale - SPACE;
 }
 
 void
@@ -931,8 +903,8 @@ SwitchWindow::updateIconNontexturedWindo
     width  = icon->width ()  * sAttrib.xScale;
     height = icon->height () * sAttrib.yScale;
 
-    wx = x + SPACE + ((WIDTH  - (SPACE << 1)) - width)  / 2;
-    wy = y + SPACE + ((HEIGHT - (SPACE << 1)) - height) / 2;
+    wx = x + SPACE + (sScreen->modifiedWidth  - (SPACE << 1) - width)  / 2;
+    wy = y + SPACE + (sScreen->modifiedHeight - (SPACE << 1) - height) / 2;
 }
 
 void
@@ -943,8 +915,8 @@ SwitchWindow::updateIconPos (int   &wx,
 			     float width,
 			     float height)
 {
-    wx = x + SPACE + ((WIDTH  - (SPACE << 1)) - width)  / 2;
-    wy = y + SPACE + ((HEIGHT - (SPACE << 1)) - height) / 2;
+    wx = x + SPACE + (sScreen->modifiedWidth  - (SPACE << 1) - width)  / 2;
+    wy = y + SPACE + (sScreen->modifiedHeight - (SPACE << 1) - height) / 2;
 }
 
 
@@ -993,10 +965,11 @@ SwitchWindow::glPaint (const GLWindowPai
 
 	foreach (CompWindow *w, sScreen->windows)
 	{
-	    if (x + WIDTH > x1)
+	    if (x + sScreen->modifiedWidth > x1) {
 		SwitchWindow::get (w)->paintThumb (gWindow->lastPaintAttrib (),
 		                                   transform, mask, x, y);
-	    x += WIDTH;
+	    }
+	    x += sScreen->modifiedWidth;
 	}
 
 	foreach (CompWindow *w, sScreen->windows)
@@ -1006,7 +979,7 @@ SwitchWindow::glPaint (const GLWindowPai
 
             SwitchWindow::get (w)->paintThumb (gWindow->lastPaintAttrib (),
 	                                       transform, mask, x, y);
-	    x += WIDTH;
+	    x += sScreen->modifiedWidth;
 	}
 
 	glDisable (GL_SCISSOR_TEST);
@@ -1025,7 +998,7 @@ SwitchWindow::glPaint (const GLWindowPai
 	streamingBuffer->begin (GL_TRIANGLES);
 
 	streamingBuffer->addColors (1, color);
-	streamingBuffer->addVertices (24, _boxVertices);
+	streamingBuffer->addVertices (24, sScreen->_boxVertices);
 
 	streamingBuffer->end ();
 	streamingBuffer->render (wTransform, attrib);
@@ -1102,6 +1075,48 @@ SwitchScreen::setZoom ()
 
 }
 
+void SwitchScreen::setSizeMultiplier () {
+	sizeMultiplier = optionGetSizeMultiplier ();
+
+	modifiedWidth = static_cast<int> (WIDTH * sizeMultiplier);
+	modifiedHeight = static_cast<int> (HEIGHT * sizeMultiplier);
+
+	float width = (WIDTH >> 1) * sizeMultiplier;
+	float height = HEIGHT * sizeMultiplier;
+	float box_width = BOX_WIDTH * sizeMultiplier;
+	float boxVertices[72] =
+	{
+		-width, box_width,  0.0f,
+		width,  box_width,  0.0f,
+		-width, 0.0f,       0.0f,
+		-width, 0.0f,       0.0f,
+		width,  box_width,  0.0f,
+		width,  0.0f,       0.0f,
+
+		-width,             height - box_width, 0.0f,
+		-width + box_width, height - box_width, 0.0f,
+		-width,             box_width,          0.0f,
+		-width,             box_width,          0.0f,
+		-width + box_width, height - box_width, 0.0f,
+		-width + box_width, box_width,          0.0f,
+
+		width - box_width,  height - box_width, 0.0f,
+		width,              height - box_width, 0.0f,
+		width - box_width,  box_width,          0.0f,
+		width - box_width,  box_width,          0.0f,
+		width,              height - box_width, 0.0f,
+		width,              box_width,          0.0f,
+
+		-width, height,             0.0f,
+		width, height,             0.0f,
+		-width, height - box_width, 0.0f,
+		-width, height - box_width, 0.0f,
+		width, height,             0.0f,
+		width, height - box_width, 0.0f,
+	};
+	std::copy (boxVertices, boxVertices + 72, _boxVertices);
+}
+
 SwitchScreen::SwitchScreen (CompScreen *screen) :
     BaseSwitchScreen (screen),
     PluginClassHandler<SwitchScreen,CompScreen> (screen),
@@ -1115,7 +1130,10 @@ SwitchScreen::SwitchScreen (CompScreen *
     pos (0),
     move (0),
     translate (0.0),
-    sTranslate (0.0)
+    sTranslate (0.0),
+    sizeMultiplier (1),
+    modifiedWidth (WIDTH),
+    modifiedHeight (HEIGHT)
 {
     zoom = optionGetZoom () / 30.0f;
 
@@ -1123,6 +1141,9 @@ SwitchScreen::SwitchScreen (CompScreen *
 
     optionSetZoomNotify (boost::bind (&SwitchScreen::setZoom, this));
 
+    setSizeMultiplier ();
+    optionSetSizeMultiplierNotify (boost::bind (&SwitchScreen::setSizeMultiplier, this));
+
     auto bgUpdater = [=] (...){ this->updateBackground (this->optionGetUseBackgroundColor (), this->optionGetBackgroundColor ());};
     optionSetUseBackgroundColorNotify (bgUpdater);
     optionSetBackgroundColorNotify (bgUpdater);
diff -Npur compiz-0.9.13.0.orig/plugins/switcher/src/switcher.h compiz-0.9.13.0/plugins/switcher/src/switcher.h
--- compiz-0.9.13.0.orig/plugins/switcher/src/switcher.h	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/plugins/switcher/src/switcher.h	2016-10-15 10:09:09.000000000 +0200
@@ -20,7 +20,9 @@
  * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
  * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  *
- * Author: David Reveman <davidr@novell.com>
+ * Author(s):
+ *  - David Reveman <davidr@novell.com>
+ *  - Auboyneau Vincent <ksamak@riseup.net> (size multiplier for A11Y)
  */
 
 #include <stdio.h>
@@ -96,6 +98,13 @@ class SwitchScreen :
 
 	float translate;
 	float sTranslate;
+
+	void setSizeMultiplier ();
+	float sizeMultiplier;
+	int modifiedWidth;
+	int modifiedHeight;
+	float _boxVertices[72];
+
 };
 
 class SwitchWindow :
@@ -160,8 +169,8 @@ extern const unsigned short SPACE;
 
 extern const unsigned short BOX_WIDTH;
 
-#define WINDOW_WIDTH(count) (WIDTH * (count) + (SPACE << 1))
-#define WINDOW_HEIGHT (HEIGHT + (SPACE << 1))
+#define WINDOW_WIDTH(count) (static_cast<int>(WIDTH * sizeMultiplier) * (count) + (SPACE << 1))
+#define WINDOW_HEIGHT (static_cast<int>(HEIGHT * sizeMultiplier) + (SPACE << 1))
 
 #define SWITCH_SCREEN(s) \
     SwitchScreen *ss = SwitchScreen::get (s)
diff -Npur compiz-0.9.13.0.orig/plugins/switcher/switcher.xml.in compiz-0.9.13.0/plugins/switcher/switcher.xml.in
--- compiz-0.9.13.0.orig/plugins/switcher/switcher.xml.in	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/plugins/switcher/switcher.xml.in	2016-10-15 10:09:09.000000000 +0200
@@ -98,6 +98,14 @@
 		<max>50</max>
 		<precision>0.1</precision>
 	    </option>
+	    <option name="size_multiplier" type="float">
+		<_short>Size multiplier</_short>
+		<_long>adjusts the size of the switch windows</_long>
+		<default>1</default>
+		<min>0.1</min>
+		<max>10</max>
+		<precision>0.1</precision>
+	    </option>
 	    <option name="window_match" type="match">
 		<_short>Switcher windows</_short>
 		<_long>Windows that should be shown in switcher</_long>
diff -Npur compiz-0.9.13.0.orig/plugins/trailfocus/src/trailfocus.cpp compiz-0.9.13.0/plugins/trailfocus/src/trailfocus.cpp
--- compiz-0.9.13.0.orig/plugins/trailfocus/src/trailfocus.cpp	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/plugins/trailfocus/src/trailfocus.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -195,7 +195,8 @@ TrailfocusScreen::popWindow (TrailfocusW
 	}
 	else
 	{
-	    distance = abs (cur->activeNum () - best->activeNum ());
+	    distance = abs (static_cast<int> (cur->activeNum ()) -
+	                    static_cast<int> (best->activeNum ()));
 	    if (distance < bestDist)
 	    {
 		best     = cur;
diff -Npur compiz-0.9.13.0.orig/src/plugin.cpp compiz-0.9.13.0/src/plugin.cpp
--- compiz-0.9.13.0.orig/src/plugin.cpp	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/src/plugin.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -132,60 +132,6 @@ cloaderUnloadPlugin (CompPlugin *p)
 }
 
 static bool
-setOpenGLPluginEnvironment ()
-{
-    /*
-     * Check if the hardware is adequate for Unity and if not, use LLVMpipe.
-     * Unfortunately the design of Mesa requires that this be done before
-     * libGL is loaded, which means before the opengl plugin is loaded.
-     */
-    bool toggledLLVM = false;
-
-    if (!getenv ("LIBGL_ALWAYS_SOFTWARE"))
-    {
-	const char *profile = getenv ("COMPIZ_CONFIG_PROFILE");
-	if (profile && strcmp (profile, "ubuntu") == 0)
-	{
-	    int result = system ("/usr/lib/nux/unity_support_test");
-	    int status = WEXITSTATUS (result);
-	    compLogMessage ("core", CompLogLevelInfo,
-		"Unity is %s",
-		status == 0 ?   "fully supported by your hardware." :
-		status == 127 ? "undetectable" :
-		                "not supported by your hardware. "
-		                "Enabling software rendering instead (slow).");
-	    if (status > 0 && status < 127)
-	    {
-		setenv ("LIBGL_ALWAYS_SOFTWARE", "1", 1);
-		toggledLLVM = true;
-	    }
-	}
-    }
-
-    return toggledLLVM;
-}
-
-static void
-unsetUnityshellPluginEnvironment ()
-{
-    unsetenv ("LIBGL_ALWAYS_SOFTWARE");
-}
-
-static void
-setPluginEnvironment (const char *name)
-{
-    if (strcmp (name, "opengl") == 0)
-	setOpenGLPluginEnvironment ();
-}
-
-static void
-unsetPluginEnvironment (const char *name)
-{
-    if (strcmp (name, "unityshell") == 0)
-	unsetUnityshellPluginEnvironment ();
-}
-
-static bool
 dlloaderLoadPlugin (CompPlugin *p,
 		    const char *path,
 		    const char *name)
@@ -197,8 +143,6 @@ dlloaderLoadPlugin (CompPlugin *p,
     if (cloaderLoadPlugin (p, path, name))
 	return true;
 
-    setPluginEnvironment (name);
-
     if (path)
     {
 	file  = path;
@@ -269,8 +213,6 @@ dlloaderLoadPlugin (CompPlugin *p,
     if (!loaded && dlhand)
 	dlclose (dlhand);
 
-    unsetPluginEnvironment (name);
-
     return loaded;
 }
 
diff -Npur compiz-0.9.13.0.orig/src/screen.cpp compiz-0.9.13.0/src/screen.cpp
--- compiz-0.9.13.0.orig/src/screen.cpp	2016-07-01 13:39:57.000000000 +0200
+++ compiz-0.9.13.0/src/screen.cpp	2016-10-15 10:09:09.000000000 +0200
@@ -2782,26 +2782,13 @@ CompScreenImpl::focusDefaultWindow ()
 				      CompWindowTypeDialogMask |
 				      CompWindowTypeModalDialogMask))
 		    {
-			if (!privateScreen.optionGetClickToFocus ())
-			{
-			    /* We should favor the more active window in the mouse focus
-			     * case since the user does not care if the focused window is on top */
-			    if (PrivateWindow::compareWindowActiveness (focus, w) < 0)
-				focus = w;
-			}
-			else
-			{
+			if (PrivateWindow::compareWindowActiveness (focus, w) < 0)
 			    focus = w;
-			    break;
-			}
 		    }
 		}
 		else
 		{
 		    focus = w;
-
-		    if (privateScreen.optionGetClickToFocus ())
-			break;
 		}
 	    }
 	}
